// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class CuPy_bitwiseTest : BaseTestCase
    {
        [Test]
        public void bitwise_andTest()
        {
            // The number 13 is represented by 00001101.  Likewise, 17 is
            // represented by 00010001.  The bit-wise AND of 13 and 17 is
            // therefore 000000001, or 1:

            // >>> cp.bitwise_and(13, 17)
            // 1
            // 

#if TODO
            var given = cp.bitwise_and(13, 17);
            var expected =
                "1";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_and(14, 13)
            // 12
            // >>> cp.binary_repr(12)
            // '1100'
            // >>> cp.bitwise_and([14,3], 13)
            // array([12,  1])
            // 

#if TODO
             given = cp.bitwise_and(14, 13);
             expected =
                "12";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(12);
             expected =
                "'1100'";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_and({14,3}, 13);
             expected =
                "array([12,  1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_and([11,7], [4,25])
            // array([0, 1])
            // >>> cp.bitwise_and(cp.array([2,5,255]), cp.array([3,14,16]))
            // array([ 2,  4, 16])
            // >>> cp.bitwise_and([True, True], [False, True])
            // array([False,  True])
            // 

#if TODO
             given = cp.bitwise_and({11,7}, {4,25});
             expected =
                "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_and(cp.array({2,5,255}), cp.array({3,14,16}));
             expected =
                "array([ 2,  4, 16])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_and({True, True}, {False, True});
             expected =
                "array([False,  True])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void bitwise_orTest()
        {
            // The number 13 has the binaray representation 00001101. Likewise,
            // 16 is represented by 00010000.  The bit-wise OR of 13 and 16 is
            // then 000111011, or 29:

            // >>> cp.bitwise_or(13, 16)
            // 29
            // >>> cp.binary_repr(29)
            // '11101'
            // 

#if TODO
            var given = cp.bitwise_or(13, 16);
            var expected =
                "29";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(29);
             expected =
                "'11101'";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_or(32, 2)
            // 34
            // >>> cp.bitwise_or([33, 4], 1)
            // array([33,  5])
            // >>> cp.bitwise_or([33, 4], [1, 2])
            // array([33,  6])
            // 

#if TODO
             given = cp.bitwise_or(32, 2);
             expected =
                "34";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_or({33, 4}, 1);
             expected =
                "array([33,  5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_or({33, 4}, {1, 2});
             expected =
                "array([33,  6])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_or(cp.array([2, 5, 255]), cp.array([4, 4, 4]))
            // array([  6,   5, 255])
            // >>> cp.array([2, 5, 255]) | cp.array([4, 4, 4])
            // array([  6,   5, 255])
            // >>> cp.bitwise_or(cp.array([2, 5, 255, 2147483647L], dtype=cp.int32),
            // ...               cp.array([4, 4, 4, 2147483647L], dtype=cp.int32))
            // array([         6,          5,        255, 2147483647])
            // >>> cp.bitwise_or([True, True], [False, True])
            // array([ True,  True])
            // 

#if TODO
             given = cp.bitwise_or(cp.array({2, 5, 255}), cp.array({4, 4, 4}));
             expected =
                "array([  6,   5, 255])";
            Assert.AreEqual(expected, given.repr);
             given = cp.array({2, 5, 255}) | cp.array({4, 4, 4});
             expected =
                "array([  6,   5, 255])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_or(cp.array({2, 5, 255, 2147483647L}, dtype = cp.int32),;
             expected =
                "...               cp.array([4, 4, 4, 2147483647L], dtype=cp.int32))\n" +
                "array([         6,          5,        255, 2147483647])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_or({True, True}, {False, True});
             expected =
                "array([ True,  True])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void bitwise_xorTest()
        {
            // The number 13 is represented by 00001101. Likewise, 17 is
            // represented by 00010001.  The bit-wise XOR of 13 and 17 is
            // therefore 00011100, or 28:

            // >>> cp.bitwise_xor(13, 17)
            // 28
            // >>> cp.binary_repr(28)
            // '11100'
            // 

#if TODO
            var given = cp.bitwise_xor(13, 17);
            var expected =
                "28";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(28);
             expected =
                "'11100'";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_xor(31, 5)
            // 26
            // >>> cp.bitwise_xor([31,3], 5)
            // array([26,  6])
            // 

#if TODO
             given = cp.bitwise_xor(31, 5);
             expected =
                "26";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_xor({31,3}, 5);
             expected =
                "array([26,  6])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.bitwise_xor([31,3], [5,6])
            // array([26,  5])
            // >>> cp.bitwise_xor([True, True], [False, True])
            // array([ True, False])
            // 

#if TODO
             given = cp.bitwise_xor({31,3}, {5,6});
             expected =
                "array([26,  5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bitwise_xor({True, True}, {False, True});
             expected =
                "array([ True, False])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void invertTest()
        {
            // We’ve seen that 13 is represented by 00001101.
            // The invert or bit-wise NOT of 13 is then:

            // >>> cp.invert(cp.array([13], dtype=uint8))
            // array([242], dtype=uint8)
            // >>> cp.binary_repr(x, width=8)
            // '00001101'
            // >>> cp.binary_repr(242, width=8)
            // '11110010'
            // 

#if TODO
            var given = cp.invert(cp.array({13}, dtype = uint8));
            var expected =
                "array([242], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(x, width = 8);
             expected =
                "'00001101'";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(242, width = 8);
             expected =
                "'11110010'";
            Assert.AreEqual(expected, given.repr);
#endif
            // The result depends on the bit-width:

            // >>> cp.invert(cp.array([13], dtype=uint16))
            // array([65522], dtype=uint16)
            // >>> cp.binary_repr(x, width=16)
            // '0000000000001101'
            // >>> cp.binary_repr(65522, width=16)
            // '1111111111110010'
            // 

#if TODO
             given = cp.invert(cp.array({13}, dtype = uint16));
             expected =
                "array([65522], dtype=uint16)";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(x, width = 16);
             expected =
                "'0000000000001101'";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(65522, width = 16);
             expected =
                "'1111111111110010'";
            Assert.AreEqual(expected, given.repr);
#endif
            // When using signed integer types the result is the two’s complement of
            // the result for the unsigned type:

            // >>> cp.invert(cp.array([13], dtype=int8))
            // array([-14], dtype=int8)
            // >>> cp.binary_repr(-14, width=8)
            // '11110010'
            // 

#if TODO
             given = cp.invert(cp.array({13}, dtype = int8));
             expected =
                "array([-14], dtype=int8)";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(-14, width = 8);
             expected =
                "'11110010'";
            Assert.AreEqual(expected, given.repr);
#endif
            // Booleans are accepted as well:

            // >>> cp.invert(array([True, False]))
            // array([False,  True])
            // 

#if TODO
             given = cp.invert(array({True, False}));
             expected =
                "array([False,  True])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void left_shiftTest()
        {
            // >>> cp.binary_repr(5)
            // '101'
            // >>> cp.left_shift(5, 2)
            // 20
            // >>> cp.binary_repr(20)
            // '10100'
            // 

#if TODO
            var given = cp.binary_repr(5);
            var expected =
                "'101'";
            Assert.AreEqual(expected, given.repr);
             given = cp.left_shift(5, 2);
             expected =
                "20";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(20);
             expected =
                "'10100'";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.left_shift(5, [1,2,3])
            // array([10, 20, 40])
            // 

#if TODO
             given = cp.left_shift(5, {1,2,3});
             expected =
                "array([10, 20, 40])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void right_shiftTest()
        {
            // >>> cp.binary_repr(10)
            // '1010'
            // >>> cp.right_shift(10, 1)
            // 5
            // >>> cp.binary_repr(5)
            // '101'
            // 

#if TODO
            var given = cp.binary_repr(10);
            var expected =
                "'1010'";
            Assert.AreEqual(expected, given.repr);
             given = cp.right_shift(10, 1);
             expected =
                "5";
            Assert.AreEqual(expected, given.repr);
             given = cp.binary_repr(5);
             expected =
                "'101'";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.right_shift(10, [1,2,3])
            // array([5, 2, 1])
            // 

#if TODO
             given = cp.right_shift(10, {1,2,3});
             expected =
                "array([5, 2, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }

#if NOT_SUPPORTED_YET
        [Test]
        public void packbitsTest()
        {
            // >>> a = cp.array([[[1,0,1],
            // ...                [0,1,0]],
            // ...               [[1,1,0],
            // ...                [0,0,1]]])
            // >>> b = cp.packbits(a, axis=-1)
            // >>> b
            // array([[[160],[64]],[[192],[32]]], dtype=uint8)
            // 

            var a = cp.array(new[,,]
            {
                {
                    { 1, 0, 1 },
                    { 0, 1, 0 }
                },
                {
                    { 1, 1, 0 },
                    { 0, 0, 1 }
                }
            });
            var b = a.packbits(-1);
            var given = b;
            var expected =
                "array([[[160],\n        [ 64]],\n\n       [[192],\n        [ 32]]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
            // Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
            // and 32 = 0010 0000.            
        }
#endif

#if NOT_SUPPORTED
        [Test]
        public void unpackbitsTest()
        {
            // >>> a = cp.array([[2], [7], [23]], dtype=cp.uint8)
            // >>> a
            // array([[ 2],
            //        [ 7],
            //        [23]], dtype=uint8)
            // >>> b = cp.unpackbits(a, axis=1)
            // >>> b
            // array([[0, 0, 0, 0, 0, 0, 1, 0],
            //        [0, 0, 0, 0, 0, 1, 1, 1],
            //        [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
            // 

            NDarray a = cp.array(new[,] { { (byte)2 }, { (byte)7 }, { (byte)23 } }, cp.uint8);
            var given = a;
            var expected =
                "array([[ 2],\n" +
                "       [ 7],\n" +
                "       [23]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
            var b = a.unpackbits(1);
            given = b;
            expected =
                "array([[0, 0, 0, 0, 0, 0, 1, 0],\n" +
                "       [0, 0, 0, 0, 0, 1, 1, 1],\n" +
                "       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
        }
#endif

        [Test]
        public void binary_reprTest()
        {
            // >>> cp.binary_repr(3)
            // '11'
            // >>> cp.binary_repr(-3)
            // '-11'
            // >>> cp.binary_repr(3, width=4)
            // '0011'
            // 

            var given = cp.binary_repr(3);
            var expected =
                "11";
            Assert.AreEqual(expected, given);
            given = cp.binary_repr(-3);
            expected =
                "-11";
            Assert.AreEqual(expected, given);
            given = cp.binary_repr(3, 4);
            expected =
                "0011";
            Assert.AreEqual(expected, given);

            // The two’s complement is returned when the input number is negative and
            // width is specified:

            // >>> cp.binary_repr(-3, width=3)
            // '101'
            // >>> cp.binary_repr(-3, width=5)
            // '11101'
            // 

            given = cp.binary_repr(-3, 3);
            expected =
                "101";
            Assert.AreEqual(expected, given);
            given = cp.binary_repr(-3, 5);
            expected =
                "11101";
            Assert.AreEqual(expected, given);
        }
    }
}