// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class CuPy_datetimeTest : BaseTestCase
    {
        [Test]
        public void datetime_as_stringTest()
        {
            // >>> d = cp.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
            // >>> d
            // array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
            //        '2002-10-27T07:30'], dtype='datetime64[m]')
            // 

#if TODO
            var given = d = cp.arange('2002-10-27T04:30', 4*60, 60, dtype = 'M8{m}');
             given = d;
            var expected =
                "array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n" +
                "       '2002-10-27T07:30'], dtype='datetime64[m]')";
            Assert.That(expected, given.repr);
#endif
            // Setting the timezone to UTC shows the same information, but with a Z suffix

            // >>> cp.datetime_as_string(d, timezone='UTC')
            // array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
            //        '2002-10-27T07:30Z'], dtype='<U35')
            // 

#if TODO
             given = cp.datetime_as_string(d, timezone = 'UTC');
             expected =
                "array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n" +
                "       '2002-10-27T07:30Z'], dtype='<U35')";
            Assert.That(expected, given.repr);
#endif
            // Note that we picked datetimes that cross a DST boundary. Passing in a
            // pytz timezone object will print the appropriate offset

            // >>> cp.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
            // array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
            //        '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')
            // 

#if TODO
             given = cp.datetime_as_string(d, timezone = pytz.timezone('US/Eastern'));
             expected =
                "array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n" +
                "       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')";
            Assert.That(expected, given.repr);
#endif
            // Passing in a unit will change the precision

            // >>> cp.datetime_as_string(d, unit='h')
            // array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
            //       dtype='<U32')
            // >>> cp.datetime_as_string(d, unit='s')
            // array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
            //        '2002-10-27T07:30:00'], dtype='<U38')
            // 

#if TODO
             given = cp.datetime_as_string(d, unit = 'h');
             expected =
                "array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n" +
                "      dtype='<U32')";
            Assert.That(expected, given.repr);
             given = cp.datetime_as_string(d, unit = 's');
             expected =
                "array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n" +
                "       '2002-10-27T07:30:00'], dtype='<U38')";
            Assert.That(expected, given.repr);
#endif
            // ‘casting’ can be used to specify whether precision can be changed

            // >>> cp.datetime_as_string(d, unit='h', casting='safe')
            // TypeError: Cannot create a datetime string as units 'h' from a Cupy
            // datetime with units 'm' according to the rule 'safe'
            // 

#if TODO
             given = cp.datetime_as_string(d, unit = 'h', casting = 'safe');
             expected =
                "TypeError: Cannot create a datetime string as units 'h' from a Cupy\n" +
                "datetime with units 'm' according to the rule 'safe'";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void datetime_dataTest()
        {
            // >>> dt_25s = cp.dtype('timedelta64[25s]')
            // >>> cp.datetime_data(dt_25s)
            // ('s', 25)
            // >>> cp.array(10, dt_25s).astype('timedelta64[s]')
            // array(250, dtype='timedelta64[s]')
            // 

#if TODO
            var given = dt_25s = cp.dtype('timedelta64{25s}');
             given = cp.datetime_data(dt_25s);
            var expected =
                "('s', 25)";
            Assert.That(expected, given.repr);
             given = cp.array(10, dt_25s).astype('timedelta64{s}');
             expected =
                "array(250, dtype='timedelta64[s]')";
            Assert.That(expected, given.repr);
#endif
            // The result can be used to construct a datetime that uses the same units
            // as a timedelta

            // >>> cp.datetime64('2010', cp.datetime_data(dt_25s))
            // Cupy.datetime64('2010-01-01T00:00:00', '25s')
            // 

#if TODO
             given = cp.datetime64('2010', cp.datetime_data(dt_25s));
             expected =
                "Cupy.datetime64('2010-01-01T00:00:00', '25s')";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void busdaycalendarTest()
        {
            // >>> # Some important days in July
            // ... bdd = cp.busdaycalendar(
            // ...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
            // >>> # Default is Monday to Friday weekdays
            // ... bdd.weekmask
            // array([ True,  True,  True,  True,  True, False, False], dtype='bool')
            // >>> # Any holidays already on the weekend are removed
            // ... bdd.holidays
            // array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')
            // 

#if TODO
            var given = # Some important days in July;
            var expected =
                "... bdd = cp.busdaycalendar(\n" +
                "...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])";
            Assert.That(expected, given.repr);
             given = # Default is Monday to Friday weekdays;
             expected =
                "... bdd.weekmask\n" +
                "array([ True,  True,  True,  True,  True, False, False], dtype='bool')";
            Assert.That(expected, given.repr);
             given = # Any holidays already on the weekend are removed;
             expected =
                "... bdd.holidays\n" +
                "array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void is_busdayTest()
        {
            // >>> # The weekdays are Friday, Saturday, and Monday
            // ... cp.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
            // ...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
            // array([False, False,  True], dtype='bool')
            // 

#if TODO
            var given = # The weekdays are Friday, Saturday, and Monday;
            var expected =
                "... cp.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n" +
                "...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n" +
                "array([False, False,  True], dtype='bool')";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void busday_offsetTest()
        {
            // >>> # First business day in October 2011 (not accounting for holidays)
            // ... cp.busday_offset('2011-10', 0, roll='forward')
            // Cupy.datetime64('2011-10-03','D')
            // >>> # Last business day in February 2012 (not accounting for holidays)
            // ... cp.busday_offset('2012-03', -1, roll='forward')
            // Cupy.datetime64('2012-02-29','D')
            // >>> # Third Wednesday in January 2011
            // ... cp.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
            // Cupy.datetime64('2011-01-19','D')
            // >>> # 2012 Mother's Day in Canada and the U.S.
            // ... cp.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
            // Cupy.datetime64('2012-05-13','D')
            // 

#if TODO
            var given = # First business day in October 2011 (not accounting for holidays);
            var expected =
                "... cp.busday_offset('2011-10', 0, roll='forward')\n" +
                "Cupy.datetime64('2011-10-03','D')";
            Assert.That(expected, given.repr);
             given = # Last business day in February 2012 (not accounting for holidays);
             expected =
                "... cp.busday_offset('2012-03', -1, roll='forward')\n" +
                "Cupy.datetime64('2012-02-29','D')";
            Assert.That(expected, given.repr);
             given = # Third Wednesday in January 2011;
             expected =
                "... cp.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\n" +
                "Cupy.datetime64('2011-01-19','D')";
            Assert.That(expected, given.repr);
             given = # 2012 Mother's Day in Canada and the U.S.;
             expected =
                "... cp.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\n" +
                "Cupy.datetime64('2012-05-13','D')";
            Assert.That(expected, given.repr);
#endif
            // >>> # First business day on or after a date
            // ... cp.busday_offset('2011-03-20', 0, roll='forward')
            // Cupy.datetime64('2011-03-21','D')
            // >>> cp.busday_offset('2011-03-22', 0, roll='forward')
            // Cupy.datetime64('2011-03-22','D')
            // >>> # First business day after a date
            // ... cp.busday_offset('2011-03-20', 1, roll='backward')
            // Cupy.datetime64('2011-03-21','D')
            // >>> cp.busday_offset('2011-03-22', 1, roll='backward')
            // Cupy.datetime64('2011-03-23','D')
            // 

#if TODO
             given = # First business day on or after a date;
             expected =
                "... cp.busday_offset('2011-03-20', 0, roll='forward')\n" +
                "Cupy.datetime64('2011-03-21','D')";
            Assert.That(expected, given.repr);
             given = cp.busday_offset('2011-03-22', 0, roll = 'forward');
             expected =
                "Cupy.datetime64('2011-03-22','D')";
            Assert.That(expected, given.repr);
             given = # First business day after a date;
             expected =
                "... cp.busday_offset('2011-03-20', 1, roll='backward')\n" +
                "Cupy.datetime64('2011-03-21','D')";
            Assert.That(expected, given.repr);
             given = cp.busday_offset('2011-03-22', 1, roll = 'backward');
             expected =
                "Cupy.datetime64('2011-03-23','D')";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void busday_countTest()
        {
            // >>> # Number of weekdays in January 2011
            // ... cp.busday_count('2011-01', '2011-02')
            // 21
            // >>> # Number of weekdays in 2011
            // ...  cp.busday_count('2011', '2012')
            // 260
            // >>> # Number of Saturdays in 2011
            // ... cp.busday_count('2011', '2012', weekmask='Sat')
            // 53
            // 

#if TODO
            var given = # Number of weekdays in January 2011;
            var expected =
                "... cp.busday_count('2011-01', '2011-02')\n" +
                "21";
            Assert.That(expected, given.repr);
             given = # Number of weekdays in 2011;
             expected =
                "...  cp.busday_count('2011', '2012')\n" +
                "260";
            Assert.That(expected, given.repr);
             given = # Number of Saturdays in 2011;
             expected =
                "... cp.busday_count('2011', '2012', weekmask='Sat')\n" +
                "53";
            Assert.That(expected, given.repr);
#endif
        }
    }
}