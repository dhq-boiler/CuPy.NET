// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class CuPy_dtype_routinesTest : BaseTestCase
    {
        [Test]
        public void can_castTest()
        {
            // Basic examples

            // >>> cp.can_cast(cp.int32, cp.int64)
            // True
            // >>> cp.can_cast(cp.float64, complex)
            // True
            // >>> cp.can_cast(complex, float)
            // False
            // 

#if TODO
            var given = cp.can_cast(cp.int32, cp.int64);
            var expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(cp.float64, complex);
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(complex, float);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast('i8', 'f8')
            // True
            // >>> cp.can_cast('i8', 'f4')
            // False
            // >>> cp.can_cast('i4', 'S4')
            // False
            // 

#if TODO
             given = cp.can_cast('i8', 'f8');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('i8', 'f4');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('i4', 'S4');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // Casting scalars

            // >>> cp.can_cast(100, 'i1')
            // True
            // >>> cp.can_cast(150, 'i1')
            // False
            // >>> cp.can_cast(150, 'u1')
            // True
            // 

#if TODO
             given = cp.can_cast(100, 'i1');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(150, 'i1');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(150, 'u1');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast(3.5e100, cp.float32)
            // False
            // >>> cp.can_cast(1000.0, cp.float32)
            // True
            // 

#if TODO
             given = cp.can_cast(3.5e100, cp.float32);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(1000.0, cp.float32);
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // Array scalar checks the value, array does not

            // >>> cp.can_cast(cp.array(1000.0), cp.float32)
            // True
            // >>> cp.can_cast(cp.array([1000.0]), cp.float32)
            // False
            // 

#if TODO
             given = cp.can_cast(cp.array(1000.0), cp.float32);
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast(cp.array({1000.0}), cp.float32);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using the casting rules

            // >>> cp.can_cast('i8', 'i8', 'no')
            // True
            // >>> cp.can_cast('<i8', '>i8', 'no')
            // False
            // 

#if TODO
             given = cp.can_cast('i8', 'i8', 'no');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('<i8', '>i8', 'no');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast('<i8', '>i8', 'equiv')
            // True
            // >>> cp.can_cast('<i4', '>i8', 'equiv')
            // False
            // 

#if TODO
             given = cp.can_cast('<i8', '>i8', 'equiv');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('<i4', '>i8', 'equiv');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast('<i4', '>i8', 'safe')
            // True
            // >>> cp.can_cast('<i8', '>i4', 'safe')
            // False
            // 

#if TODO
             given = cp.can_cast('<i4', '>i8', 'safe');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('<i8', '>i4', 'safe');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast('<i8', '>i4', 'same_kind')
            // True
            // >>> cp.can_cast('<i8', '>u4', 'same_kind')
            // False
            // 

#if TODO
             given = cp.can_cast('<i8', '>i4', 'same_kind');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.can_cast('<i8', '>u4', 'same_kind');
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.can_cast('<i8', '>u4', 'unsafe')
            // True
            // 

#if TODO
             given = cp.can_cast('<i8', '>u4', 'unsafe');
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void promote_typesTest()
        {
            // >>> cp.promote_types('f4', 'f8')
            // dtype('float64')
            // 

#if TODO
            var given = cp.promote_types('f4', 'f8');
            var expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.promote_types('i8', 'f4')
            // dtype('float64')
            // 

#if TODO
             given = cp.promote_types('i8', 'f4');
             expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.promote_types('>i8', '<c8')
            // dtype('complex128')
            // 

#if TODO
             given = cp.promote_types('>i8', '<c8');
             expected =
                "dtype('complex128')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.promote_types('i4', 'S8')
            // dtype('S11')
            // 

#if TODO
             given = cp.promote_types('i4', 'S8');
             expected =
                "dtype('S11')";
            Assert.AreEqual(expected, given.repr);
#endif
            // An example of a non-associative case:

            // >>> p = cp.promote_types
            // >>> p('S', p('i1', 'u1'))
            // dtype('S6')
            // >>> p(p('S', 'i1'), 'u1')
            // dtype('S4')
            // 

#if TODO
             given = p = cp.promote_types;
             given = p('S', p('i1', 'u1'));
             expected =
                "dtype('S6')";
            Assert.AreEqual(expected, given.repr);
             given = p(p('S', 'i1'), 'u1');
             expected =
                "dtype('S4')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void min_scalar_typeTest()
        {
            // >>> cp.min_scalar_type(10)
            // dtype('uint8')
            // 

#if TODO
            var given = cp.min_scalar_type(10);
            var expected =
                "dtype('uint8')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.min_scalar_type(-260)
            // dtype('int16')
            // 

#if TODO
             given = cp.min_scalar_type(-260);
             expected =
                "dtype('int16')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.min_scalar_type(3.1)
            // dtype('float16')
            // 

#if TODO
             given = cp.min_scalar_type(3.1);
             expected =
                "dtype('float16')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.min_scalar_type(1e50)
            // dtype('float64')
            // 

#if TODO
             given = cp.min_scalar_type(1e50);
             expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.min_scalar_type(cp.arange(4,dtype='f8'))
            // dtype('float64')
            // 

#if TODO
             given = cp.min_scalar_type(cp.arange(4,dtype = 'f8'));
             expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void result_typeTest()
        {
            // >>> cp.result_type(3, cp.arange(7, dtype='i1'))
            // dtype('int8')
            // 

#if TODO
            var given = cp.result_type(3, cp.arange(7, dtype = 'i1'));
            var expected =
                "dtype('int8')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.result_type('i4', 'c8')
            // dtype('complex128')
            // 

#if TODO
             given = cp.result_type('i4', 'c8');
             expected =
                "dtype('complex128')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.result_type(3.0, -2)
            // dtype('float64')
            // 

#if TODO
             given = cp.result_type(3.0, -2);
             expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void common_typeTest()
        {
            // >>> cp.common_type(cp.arange(2, dtype=cp.float32))
            // <type 'Cupy.float32'>
            // >>> cp.common_type(cp.arange(2, dtype=cp.float32), cp.arange(2))
            // <type 'Cupy.float64'>
            // >>> cp.common_type(cp.arange(4), cp.array([45, 6.j]), cp.array([45.0]))
            // <type 'Cupy.complex128'>
            // 

#if TODO
            var given = cp.common_type(cp.arange(2, dtype = cp.float32));
            var expected =
                "<type 'Cupy.float32'>";
            Assert.AreEqual(expected, given.repr);
             given = cp.common_type(cp.arange(2, dtype = cp.float32), cp.arange(2));
             expected =
                "<type 'Cupy.float64'>";
            Assert.AreEqual(expected, given.repr);
             given = cp.common_type(cp.arange(4), cp.array({45, 6.j}), cp.array({45.0}));
             expected =
                "<type 'Cupy.complex128'>";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void obj2sctypeTest()
        {
            // >>> cp.obj2sctype(cp.int32)
            // <type 'Cupy.int32'>
            // >>> cp.obj2sctype(cp.array([1., 2.]))
            // <type 'Cupy.float64'>
            // >>> cp.obj2sctype(cp.array([1.j]))
            // <type 'Cupy.complex128'>
            // 

#if TODO
            var given = cp.obj2sctype(cp.int32);
            var expected =
                "<type 'Cupy.int32'>";
            Assert.AreEqual(expected, given.repr);
             given = cp.obj2sctype(cp.array({1., 2.}));
             expected =
                "<type 'Cupy.float64'>";
            Assert.AreEqual(expected, given.repr);
             given = cp.obj2sctype(cp.array({1.j}));
             expected =
                "<type 'Cupy.complex128'>";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.obj2sctype(dict)
            // <type 'Cupy.object_'>
            // >>> cp.obj2sctype('string')
            // <type 'Cupy.string_'>
            // 

#if TODO
             given = cp.obj2sctype(dict);
             expected =
                "<type 'Cupy.object_'>";
            Assert.AreEqual(expected, given.repr);
             given = cp.obj2sctype('string');
             expected =
                "<type 'Cupy.string_'>";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.obj2sctype(1, default=list)
            // <type 'list'>
            // 

#if TODO
             given = cp.obj2sctype(1, default = list);
             expected =
                "<type 'list'>";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void dtypeTest()
        {
            // Using array-scalar type:

            // >>> cp.dtype(cp.int16)
            // dtype('int16')
            // 

#if TODO
            var given = cp.dtype(cp.int16);
            var expected =
                "dtype('int16')";
            Assert.AreEqual(expected, given.repr);
#endif
            // Structured type, one field name ‘f1’, containing int16:

            // >>> cp.dtype([('f1', cp.int16)])
            // dtype([('f1', '<i2')])
            // 

#if TODO
             given = cp.dtype({('f1', cp.int16)});
             expected =
                "dtype([('f1', '<i2')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Structured type, one field named ‘f1’, in itself containing a structured
            // type with one field:

            // >>> cp.dtype([('f1', [('f1', cp.int16)])])
            // dtype([('f1', [('f1', '<i2')])])
            // 

#if TODO
             given = cp.dtype({('f1', {('f1', cp.int16)})});
             expected =
                "dtype([('f1', [('f1', '<i2')])])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Structured type, two fields: the first field contains an unsigned int, the
            // second an int32:

            // >>> cp.dtype([('f1', cp.uint), ('f2', cp.int32)])
            // dtype([('f1', '<u4'), ('f2', '<i4')])
            // 

#if TODO
             given = cp.dtype({('f1', cp.uint), ('f2', cp.int32)});
             expected =
                "dtype([('f1', '<u4'), ('f2', '<i4')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using array-protocol type strings:

            // >>> cp.dtype([('a','f8'),('b','S10')])
            // dtype([('a', '<f8'), ('b', '|S10')])
            // 

#if TODO
             given = cp.dtype({('a','f8'),('b','S10')});
             expected =
                "dtype([('a', '<f8'), ('b', '|S10')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using comma-separated field formats.  The shape is (2,3):

            // >>> cp.dtype("i4, (2,3)f8")
            // dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])
            // 

#if TODO
             given = cp.dtype("i4, (2,3)f8");
             expected =
                "dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using tuples.  int is a fixed type, 3 the field’s shape.  void
            // is a flexible type, here of size 10:

            // >>> cp.dtype([('hello',(int,3)),('world',cp.void,10)])
            // dtype([('hello', '<i4', 3), ('world', '|V10')])
            // 

#if TODO
             given = cp.dtype({('hello',(int,3)),('world',cp.void,10)});
             expected =
                "dtype([('hello', '<i4', 3), ('world', '|V10')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Subdivide int16 into 2 int8’s, called x and y.  0 and 1 are
            // the offsets in bytes:

            // >>> cp.dtype((cp.int16, {'x':(cp.int8,0), 'y':(cp.int8,1)}))
            // dtype(('<i2', [('x', '|i1'), ('y', '|i1')]))
            // 

#if TODO
             given = cp.dtype((cp.int16, {'x':(cp.int8,0), 'y':(cp.int8,1)}));
             expected =
                "dtype(('<i2', [('x', '|i1'), ('y', '|i1')]))";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using dictionaries.  Two fields named ‘gender’ and ‘age’:

            // >>> cp.dtype({'names':['gender','age'], 'formats':['S1',cp.uint8]})
            // dtype([('gender', '|S1'), ('age', '|u1')])
            // 

#if TODO
             given = cp.dtype({'names':{'gender','age'}, 'formats':{'S1',cp.uint8}});
             expected =
                "dtype([('gender', '|S1'), ('age', '|u1')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Offsets in bytes, here 0 and 25:

            // >>> cp.dtype({'surname':('S25',0),'age':(cp.uint8,25)})
            // dtype([('surname', '|S25'), ('age', '|u1')])
            // 

#if TODO
             given = cp.dtype({'surname':('S25',0),'age':(cp.uint8,25)});
             expected =
                "dtype([('surname', '|S25'), ('age', '|u1')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> dt = cp.dtype('i2')
            // >>> dt.byteorder
            // '='
            // >>> # endian is not relevant for 8 bit numbers
            // >>> cp.dtype('i1').byteorder
            // '|'
            // >>> # or ASCII strings
            // >>> cp.dtype('S2').byteorder
            // '|'
            // >>> # Even if specific code is given, and it is native
            // >>> # '=' is the byteorder
            // >>> import sys
            // >>> sys_is_le = sys.byteorder == 'little'
            // >>> native_code = sys_is_le and '<' or '>'
            // >>> swapped_code = sys_is_le and '>' or '<'
            // >>> dt = cp.dtype(native_code + 'i2')
            // >>> dt.byteorder
            // '='
            // >>> # Swapped code shows up as itself
            // >>> dt = cp.dtype(swapped_code + 'i2')
            // >>> dt.byteorder == swapped_code
            // True
            // 

#if TODO
             given = dt = cp.dtype('i2');
             given = dt.byteorder;
             expected =
                "'='";
            Assert.AreEqual(expected, given.repr);
             given = # endian is not relevant for 8 bit numbers;
             given = cp.dtype('i1').byteorder;
             expected =
                "'|'";
            Assert.AreEqual(expected, given.repr);
             given = # or ASCII strings;
             given = cp.dtype('S2').byteorder;
             expected =
                "'|'";
            Assert.AreEqual(expected, given.repr);
             given = # Even if specific code is given, and it is native;
             given = # '=' is the byteorder;
             given = import sys;
             given = sys_is_le = sys.byteorder == 'little';
             given = native_code = sys_is_le and '<' or '>';
             given = swapped_code = sys_is_le and '>' or '<';
             given = dt = cp.dtype(native_code + 'i2');
             given = dt.byteorder;
             expected =
                "'='";
            Assert.AreEqual(expected, given.repr);
             given = # Swapped code shows up as itself;
             given = dt = cp.dtype(swapped_code + 'i2');
             given = dt.byteorder == swapped_code;
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // Methods
        }


        [Test]
        public void format_parserTest()
        {
            // >>> cp.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
            // ...                  ['T1', 'T2', 'T3']).dtype
            // dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'),
            //        (('T3', 'col3'), '|S5')])
            // 

#if TODO
            var given = cp.format_parser({'f8', 'i4', 'a5'}, {'col1', 'col2', 'col3'},;
            var expected =
                "...                  ['T1', 'T2', 'T3']).dtype\n" +
                "dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'),\n" +
                "       (('T3', 'col3'), '|S5')])";
            Assert.AreEqual(expected, given.repr);
#endif
            // names and/or titles can be empty lists. If titles is an empty list,
            // titles will simply not appear. If names is empty, default field names
            // will be used.

            // >>> cp.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
            // ...                  []).dtype
            // dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '|S5')])
            // >>> cp.format_parser(['f8', 'i4', 'a5'], [], []).dtype
            // dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', '|S5')])
            // 

#if TODO
             given = cp.format_parser({'f8', 'i4', 'a5'}, {'col1', 'col2', 'col3'},;
             expected =
                "...                  []).dtype\n" +
                "dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '|S5')])";
            Assert.AreEqual(expected, given.repr);
             given = cp.format_parser({'f8', 'i4', 'a5'}, {}, {}).dtype;
             expected =
                "dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', '|S5')])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void iinfoTest()
        {
            // With types:

            // >>> ii16 = cp.iinfo(cp.int16)
            // >>> ii16.min
            // -32768
            // >>> ii16.max
            // 32767
            // >>> ii32 = cp.iinfo(cp.int32)
            // >>> ii32.min
            // -2147483648
            // >>> ii32.max
            // 2147483647
            // 

#if TODO
            var given = ii16 = cp.iinfo(cp.int16);
             given = ii16.min;
            var expected =
                "-32768";
            Assert.AreEqual(expected, given.repr);
             given = ii16.max;
             expected =
                "32767";
            Assert.AreEqual(expected, given.repr);
             given = ii32 = cp.iinfo(cp.int32);
             given = ii32.min;
             expected =
                "-2147483648";
            Assert.AreEqual(expected, given.repr);
             given = ii32.max;
             expected =
                "2147483647";
            Assert.AreEqual(expected, given.repr);
#endif
            // With instances:

            // >>> ii32 = cp.iinfo(cp.int32(10))
            // >>> ii32.min
            // -2147483648
            // >>> ii32.max
            // 2147483647
            // 

#if TODO
             given = ii32 = cp.iinfo(cp.int32(10));
             given = ii32.min;
             expected =
                "-2147483648";
            Assert.AreEqual(expected, given.repr);
             given = ii32.max;
             expected =
                "2147483647";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void issctypeTest()
        {
            // >>> cp.issctype(cp.int32)
            // True
            // >>> cp.issctype(list)
            // False
            // >>> cp.issctype(1.1)
            // False
            // 

#if TODO
            var given = cp.issctype(cp.int32);
            var expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.issctype(list);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
             given = cp.issctype(1.1);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
            // Strings are also a scalar type:

            // >>> cp.issctype(cp.dtype('str'))
            // True
            // 

#if TODO
             given = cp.issctype(cp.dtype('str'));
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void issubdtypeTest()
        {
            // >>> cp.issubdtype('S1', cp.string_)
            // True
            // >>> cp.issubdtype(cp.float64, cp.float32)
            // False
            // 

#if TODO
            var given = cp.issubdtype('S1', cp.string_);
            var expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.issubdtype(cp.float64, cp.float32);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void issubsctypeTest()
        {
            // >>> cp.issubsctype('S8', str)
            // True
            // >>> cp.issubsctype(cp.array([1]), int)
            // True
            // >>> cp.issubsctype(cp.array([1]), float)
            // False
            // 

#if TODO
            var given = cp.issubsctype('S8', str);
            var expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.issubsctype(cp.array({1}), int);
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.issubsctype(cp.array({1}), float);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void issubclass_Test()
        {
            // >>> cp.issubclass_(cp.int32, int)
            // True
            // >>> cp.issubclass_(cp.int32, float)
            // False
            // 

#if TODO
            var given = cp.issubclass_(cp.int32, int);
            var expected =
                "True";
            Assert.AreEqual(expected, given.repr);
             given = cp.issubclass_(cp.int32, float);
             expected =
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void find_common_typeTest()
        {
            // >>> cp.find_common_type([], [cp.int64, cp.float32, complex])
            // dtype('complex128')
            // >>> cp.find_common_type([cp.int64, cp.float32], [])
            // dtype('float64')
            // 

#if TODO
            var given = cp.find_common_type({}, {cp.int64, cp.float32, complex});
            var expected =
                "dtype('complex128')";
            Assert.AreEqual(expected, given.repr);
             given = cp.find_common_type({cp.int64, cp.float32}, {});
             expected =
                "dtype('float64')";
            Assert.AreEqual(expected, given.repr);
#endif
            // The standard casting rules ensure that a scalar cannot up-cast an
            // array unless the scalar is of a fundamentally different kind of data
            // (i.e. under a different hierarchy in the data type hierarchy) then
            // the array:

            // >>> cp.find_common_type([cp.float32], [cp.int64, cp.float64])
            // dtype('float32')
            // 

#if TODO
             given = cp.find_common_type({cp.float32}, {cp.int64, cp.float64});
             expected =
                "dtype('float32')";
            Assert.AreEqual(expected, given.repr);
#endif
            // Complex is of a different type, so it up-casts the float in the
            // array_types argument:

            // >>> cp.find_common_type([cp.float32], [complex])
            // dtype('complex128')
            // 

#if TODO
             given = cp.find_common_type({cp.float32}, {complex});
             expected =
                "dtype('complex128')";
            Assert.AreEqual(expected, given.repr);
#endif
            // Type specifier strings are convertible to dtypes and can therefore
            // be used instead of dtypes:

            // >>> cp.find_common_type(['f4', 'f4', 'i4'], ['c8'])
            // dtype('complex128')
            // 

#if TODO
             given = cp.find_common_type({'f4', 'f4', 'i4'}, {'c8'});
             expected =
                "dtype('complex128')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void typenameTest()
        {
            // >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
            // ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
            // >>> for typechar in typechars:
            // ...     print(typechar, ' : ', cp.typename(typechar))
            // ...
            // S1  :  character
            // ?  :  bool
            // B  :  unsigned char
            // D  :  complex double precision
            // G  :  complex long double precision
            // F  :  complex single precision
            // I  :  unsigned integer
            // H  :  unsigned short
            // L  :  unsigned long integer
            // O  :  object
            // Q  :  unsigned long long integer
            // S  :  string
            // U  :  unicode
            // V  :  void
            // b  :  signed char
            // d  :  double precision
            // g  :  long precision
            // f  :  single precision
            // i  :  integer
            // h  :  short
            // l  :  long integer
            // q  :  long long integer
            // 

#if TODO
            var given = typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',;
            var expected =
                "...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']";
            Assert.AreEqual(expected, given.repr);
             given = for typechar in typechars:;
             expected =
                "...     print(typechar, ' : ', cp.typename(typechar))\n" +
                "...\n" +
                "S1  :  character\n" +
                "?  :  bool\n" +
                "B  :  unsigned char\n" +
                "D  :  complex double precision\n" +
                "G  :  complex long double precision\n" +
                "F  :  complex single precision\n" +
                "I  :  unsigned integer\n" +
                "H  :  unsigned short\n" +
                "L  :  unsigned long integer\n" +
                "O  :  object\n" +
                "Q  :  unsigned long long integer\n" +
                "S  :  string\n" +
                "U  :  unicode\n" +
                "V  :  void\n" +
                "b  :  signed char\n" +
                "d  :  double precision\n" +
                "g  :  long precision\n" +
                "f  :  single precision\n" +
                "i  :  integer\n" +
                "h  :  short\n" +
                "l  :  long integer\n" +
                "q  :  long long integer";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void sctype2charTest()
        {
            // >>> for sctype in [cp.int32, float, complex, cp.string_, cp.ndarray]:
            // ...     print(cp.sctype2char(sctype))
            // l
            // d
            // D
            // S
            // O
            // 

#if TODO
            var given = for sctype in {cp.int32, float, complex, cp.string_, cp.ndarray}:;
            var expected =
                "...     print(cp.sctype2char(sctype))\n" +
                "l\n" +
                "d\n" +
                "D\n" +
                "S\n" +
                "O";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = cp.array([1., 2-1.j])
            // >>> cp.sctype2char(x)
            // 'D'
            // >>> cp.sctype2char(list)
            // 'O'
            // 

#if TODO
             given = x = cp.array({1., 2-1.j});
             given = cp.sctype2char(x);
             expected =
                "'D'";
            Assert.AreEqual(expected, given.repr);
             given = cp.sctype2char(list);
             expected =
                "'O'";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void mintypecodeTest()
        {
            // >>> cp.mintypecode(['d', 'f', 'S'])
            // 'd'
            // >>> x = cp.array([1.1, 2-3.j])
            // >>> cp.mintypecode(x)
            // 'D'
            // 

#if TODO
            var given = cp.mintypecode({'d', 'f', 'S'});
            var expected =
                "'d'";
            Assert.AreEqual(expected, given.repr);
             given = x = cp.array({1.1, 2-3.j});
             given = cp.mintypecode(x);
             expected =
                "'D'";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.mintypecode('abceh', default='G')
            // 'G'
            // 

#if TODO
             given = cp.mintypecode('abceh', default = 'G');
             expected =
                "'G'";
            Assert.AreEqual(expected, given.repr);
#endif
        }
    }
}