// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class CuPy_fftTest : BaseTestCase
    {
        [Test]
        public void rfftTest()
        {
            // >>> cp.fft.fft([0, 1, 0, 0])
            // array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])
            // >>> cp.fft.rfft([0, 1, 0, 0])
            // array([ 1.+0.j,  0.-1.j, -1.+0.j])
            // 

#if TODO
            var given = cp.fft.fft({0, 1, 0, 0});
            var expected =
                "array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.rfft({0, 1, 0, 0});
             expected =
                "array([ 1.+0.j,  0.-1.j, -1.+0.j])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Notice how the final element of the fft output is the complex conjugate
            // of the second element, for real input. For rfft, this symmetry is
            // exploited to compute only the non-negative frequency terms.
        }


        [Test]
        public void irfftTest()
        {
            // >>> cp.fft.ifft([1, -1j, -1, 1j])
            // array([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])
            // >>> cp.fft.irfft([1, -1j, -1])
            // array([ 0.,  1.,  0.,  0.])
            // 

#if TODO
            var given = cp.fft.ifft({1, -1j, -1, 1j});
            var expected =
                "array([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.irfft({1, -1j, -1});
             expected =
                "array([ 0.,  1.,  0.,  0.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Notice how the last term in the input to the ordinary ifft is the
            // complex conjugate of the second term, and the output has zero imaginary
            // part everywhere.  When calling irfft, the negative frequencies are not
            // specified, and the output array is purely real.
        }


        [Test]
        public void rfftnTest()
        {
            // >>> a = cp.ones((2, 2, 2))
            // >>> cp.fft.rfftn(a)
            // array([[[ 8.+0.j,  0.+0.j],
            //         [ 0.+0.j,  0.+0.j]],
            //        [[ 0.+0.j,  0.+0.j],
            //         [ 0.+0.j,  0.+0.j]]])
            // 

#if TODO
            var given = a = cp.ones((2, 2, 2));
             given = cp.fft.rfftn(a);
            var expected =
                "array([[[ 8.+0.j,  0.+0.j],\n" +
                "        [ 0.+0.j,  0.+0.j]],\n" +
                "       [[ 0.+0.j,  0.+0.j],\n" +
                "        [ 0.+0.j,  0.+0.j]]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.fft.rfftn(a, axes=(2, 0))
            // array([[[ 4.+0.j,  0.+0.j],
            //         [ 4.+0.j,  0.+0.j]],
            //        [[ 0.+0.j,  0.+0.j],
            //         [ 0.+0.j,  0.+0.j]]])
            // 

#if TODO
             given = cp.fft.rfftn(a, axes = (2, 0));
             expected =
                "array([[[ 4.+0.j,  0.+0.j],\n" +
                "        [ 4.+0.j,  0.+0.j]],\n" +
                "       [[ 0.+0.j,  0.+0.j],\n" +
                "        [ 0.+0.j,  0.+0.j]]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void irfftnTest()
        {
            // >>> a = cp.zeros((3, 2, 2))
            // >>> a[0, 0, 0] = 3 * 2 * 2
            // >>> cp.fft.irfftn(a)
            // array([[[ 1.,  1.],
            //         [ 1.,  1.]],
            //        [[ 1.,  1.],
            //         [ 1.,  1.]],
            //        [[ 1.,  1.],
            //         [ 1.,  1.]]])
            // 

#if TODO
            var given = a = cp.zeros((3, 2, 2));
             given = a[0, 0, 0] = 3 * 2 * 2;
             given = cp.fft.irfftn(a);
            var expected =
                "array([[[ 1.,  1.],\n" +
                "        [ 1.,  1.]],\n" +
                "       [[ 1.,  1.],\n" +
                "        [ 1.,  1.]],\n" +
                "       [[ 1.,  1.],\n" +
                "        [ 1.,  1.]]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void hfftTest()
        {
            // >>> signal = cp.array([1, 2, 3, 4, 3, 2])
            // >>> cp.fft.fft(signal)
            // array([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])
            // >>> cp.fft.hfft(signal[:4]) # Input first half of signal
            // array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])
            // >>> cp.fft.hfft(signal, 6)  # Input entire signal and truncate
            // array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])
            // 

#if TODO
            var given = signal = cp.array({1, 2, 3, 4, 3, 2});
             given = cp.fft.fft(signal);
            var expected =
                "array([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.hfft(signal{:4}) # Input first half of signal;
             expected =
                "array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.hfft(signal, 6)  # Input entire signal and truncate;
             expected =
                "array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> signal = cp.array([[1, 1.j], [-1.j, 2]])
            // >>> cp.conj(signal.T) - signal   # check Hermitian symmetry
            // array([[ 0.-0.j,  0.+0.j],
            //        [ 0.+0.j,  0.-0.j]])
            // >>> freq_spectrum = cp.fft.hfft(signal)
            // >>> freq_spectrum
            // array([[ 1.,  1.],
            //        [ 2., -2.]])
            // 

#if TODO
             given = signal = cp.array({{1, 1.j}, {-1.j, 2}});
             given = cp.conj(signal.T) - signal   # check Hermitian symmetry;
             expected =
                "array([[ 0.-0.j,  0.+0.j],\n" +
                "       [ 0.+0.j,  0.-0.j]])";
            Assert.AreEqual(expected, given.repr);
             given = freq_spectrum = cp.fft.hfft(signal);
             given = freq_spectrum;
             expected =
                "array([[ 1.,  1.],\n" +
                "       [ 2., -2.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void ihfftTest()
        {
            // >>> spectrum = cp.array([ 15, -4, 0, -1, 0, -4])
            // >>> cp.fft.ifft(spectrum)
            // array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])
            // >>> cp.fft.ihfft(spectrum)
            // array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])
            // 

#if TODO
            var given = spectrum = cp.array({ 15, -4, 0, -1, 0, -4});
             given = cp.fft.ifft(spectrum);
            var expected =
                "array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.ihfft(spectrum);
             expected =
                "array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void fftfreqTest()
        {
            // >>> signal = cp.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
            // >>> fourier = cp.fft.fft(signal)
            // >>> n = signal.size
            // >>> timestep = 0.1
            // >>> freq = cp.fft.fftfreq(n, d=timestep)
            // >>> freq
            // array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25])
            // 

#if TODO
            var given = signal = cp.array({-2, 8, 6, 4, 1, 0, 3, 5}, dtype = float);
             given = fourier = cp.fft.fft(signal);
             given = n = signal.size;
             given = timestep = 0.1;
             given = freq = cp.fft.fftfreq(n, d = timestep);
             given = freq;
            var expected =
                "array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void rfftfreqTest()
        {
            // >>> signal = cp.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
            // >>> fourier = cp.fft.rfft(signal)
            // >>> n = signal.size
            // >>> sample_rate = 100
            // >>> freq = cp.fft.fftfreq(n, d=1./sample_rate)
            // >>> freq
            // array([  0.,  10.,  20.,  30.,  40., -50., -40., -30., -20., -10.])
            // >>> freq = cp.fft.rfftfreq(n, d=1./sample_rate)
            // >>> freq
            // array([  0.,  10.,  20.,  30.,  40.,  50.])
            // 

#if TODO
            var given = signal = cp.array({-2, 8, 6, 4, 1, 0, 3, 5, -3, 4}, dtype = float);
             given = fourier = cp.fft.rfft(signal);
             given = n = signal.size;
             given = sample_rate = 100;
             given = freq = cp.fft.fftfreq(n, d = 1./sample_rate);
             given = freq;
            var expected =
                "array([  0.,  10.,  20.,  30.,  40., -50., -40., -30., -20., -10.])";
            Assert.AreEqual(expected, given.repr);
             given = freq = cp.fft.rfftfreq(n, d = 1./sample_rate);
             given = freq;
             expected =
                "array([  0.,  10.,  20.,  30.,  40.,  50.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void fftshiftTest()
        {
            // >>> freqs = cp.fft.fftfreq(10, 0.1)
            // >>> freqs
            // array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
            // >>> cp.fft.fftshift(freqs)
            // array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
            // 

#if TODO
            var given = freqs = cp.fft.fftfreq(10, 0.1);
             given = freqs;
            var expected =
                "array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.fftshift(freqs);
             expected =
                "array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Shift the zero-frequency component only along the second axis:

            // >>> freqs = cp.fft.fftfreq(9, d=1./9).reshape(3, 3)
            // >>> freqs
            // array([[ 0.,  1.,  2.],
            //        [ 3.,  4., -4.],
            //        [-3., -2., -1.]])
            // >>> cp.fft.fftshift(freqs, axes=(1,))
            // array([[ 2.,  0.,  1.],
            //        [-4.,  3.,  4.],
            //        [-1., -3., -2.]])
            // 

#if TODO
             given = freqs = cp.fft.fftfreq(9, d = 1./9).reshape(3, 3);
             given = freqs;
             expected =
                "array([[ 0.,  1.,  2.],\n" +
                "       [ 3.,  4., -4.],\n" +
                "       [-3., -2., -1.]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.fftshift(freqs, axes = (1,));
             expected =
                "array([[ 2.,  0.,  1.],\n" +
                "       [-4.,  3.,  4.],\n" +
                "       [-1., -3., -2.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void ifftshiftTest()
        {
            // >>> freqs = cp.fft.fftfreq(9, d=1./9).reshape(3, 3)
            // >>> freqs
            // array([[ 0.,  1.,  2.],
            //        [ 3.,  4., -4.],
            //        [-3., -2., -1.]])
            // >>> cp.fft.ifftshift(cp.fft.fftshift(freqs))
            // array([[ 0.,  1.,  2.],
            //        [ 3.,  4., -4.],
            //        [-3., -2., -1.]])
            // 

#if TODO
            var given = freqs = cp.fft.fftfreq(9, d = 1./9).reshape(3, 3);
             given = freqs;
            var expected =
                "array([[ 0.,  1.,  2.],\n" +
                "       [ 3.,  4., -4.],\n" +
                "       [-3., -2., -1.]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.fft.ifftshift(cp.fft.fftshift(freqs));
             expected =
                "array([[ 0.,  1.,  2.],\n" +
                "       [ 3.,  4., -4.],\n" +
                "       [-3., -2., -1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }
    }
}