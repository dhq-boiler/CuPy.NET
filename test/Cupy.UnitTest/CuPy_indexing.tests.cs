// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class Cupy_indexingTest : BaseTestCase
    {
        [Test]
        public void r_Test()
        {
            // >>> cp.r_[cp.array([1,2,3]), 0, 0, cp.array([4,5,6])]
            // array([1, 2, 3, 0, 0, 4, 5, 6])
            // >>> cp.r_[-1:1:6j, [0]*3, 5, 6]
            // array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])
            // 

#if TODO
            var given = cp.r_{cp.array({1,2,3}), 0, 0, cp.array({4,5,6})};
            var expected =
                "array([1, 2, 3, 0, 0, 4, 5, 6])";
            Assert.AreEqual(expected, given.repr);
             given = cp.r_{-1:1:6j, {0}*3, 5, 6};
             expected =
                "array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // String integers specify the axis to concatenate along or the minimum
            // number of dimensions to force entries into.

            // >>> a = cp.array([[0, 1, 2], [3, 4, 5]])
            // >>> cp.r_['-1', a, a] # concatenate along last axis
            // array([[0, 1, 2, 0, 1, 2],
            //        [3, 4, 5, 3, 4, 5]])
            // >>> cp.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim>=2
            // array([[1, 2, 3],
            //        [4, 5, 6]])
            // 

#if TODO
             given = a = cp.array({{0, 1, 2}, {3, 4, 5}});
             given = cp.r_{'-1', a, a} # concatenate along last axis;
             expected =
                "array([[0, 1, 2, 0, 1, 2],\n" +
                "       [3, 4, 5, 3, 4, 5]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.r_{'0,2', {1,2,3}, {4,5,6}} # concatenate along first axis, dim>=2;
             expected =
                "array([[1, 2, 3],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.r_['0,2,0', [1,2,3], [4,5,6]]
            // array([[1],
            //        [2],
            //        [3],
            //        [4],
            //        [5],
            //        [6]])
            // >>> cp.r_['1,2,0', [1,2,3], [4,5,6]]
            // array([[1, 4],
            //        [2, 5],
            //        [3, 6]])
            // 

#if TODO
             given = cp.r_{'0,2,0', {1,2,3}, {4,5,6}};
             expected =
                "array([[1],\n" +
                "       [2],\n" +
                "       [3],\n" +
                "       [4],\n" +
                "       [5],\n" +
                "       [6]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.r_{'1,2,0', {1,2,3}, {4,5,6}};
             expected =
                "array([[1, 4],\n" +
                "       [2, 5],\n" +
                "       [3, 6]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using ‘r’ or ‘c’ as a first string argument creates a matrix.

            // >>> cp.r_['r',[1,2,3], [4,5,6]]
            // matrix([[1, 2, 3, 4, 5, 6]])
            // 

#if TODO
             given = cp.r_{'r',{1,2,3}, {4,5,6}};
             expected =
                "matrix([[1, 2, 3, 4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void s_Test()
        {
            // >>> cp.s_[2::2]
            // slice(2, None, 2)
            // >>> cp.index_exp[2::2]
            // (slice(2, None, 2),)
            // 

#if TODO
            var given = cp.s_{2::2};
            var expected =
                "slice(2, None, 2)";
            Assert.AreEqual(expected, given.repr);
             given = cp.index_exp{2::2};
             expected =
                "(slice(2, None, 2),)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.array([0, 1, 2, 3, 4])[cp.s_[2::2]]
            // array([2, 4])
            // 

#if TODO
             given = cp.array({0, 1, 2, 3, 4}){cp.s_{2::2}};
             expected =
                "array([2, 4])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nonzeroTest()
        {
            // >>> x = cp.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
            // >>> x
            // array([[3, 0, 0],
            //        [0, 4, 0],
            //        [5, 6, 0]])
            // >>> cp.nonzero(x)
            // (array([0, 1, 2, 2]), array([0, 1, 0, 1]))
            // 


            var x = cp.array(new[,] { { 3, 0, 0 }, { 0, 4, 0 }, { 5, 6, 0 } });
            NDarray given = x;
            var expected =
                "array([[3, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [5, 6, 0]])";
            Assert.AreEqual(expected, given.repr);
            var given1 = x.nonzero();
            expected =
                "(array([0, 1, 2, 2], dtype=int64), array([0, 1, 0, 1], dtype=int64))";
            Assert.AreEqual(expected, given1.repr());

            // >>> x[cp.nonzero(x)]
            // array([3, 4, 5, 6])
            // >>> cp.transpose(cp.nonzero(x))
            // array([[0, 0],
            //        [1, 1],
            //        [2, 0],
            //        [2, 1])
            // 


            given = x[x.nonzero()];
            expected =
                "array([3, 4, 5, 6])";
            Assert.AreEqual(expected, given.repr);
            given = x.nonzero().transpose();
            expected =
                "array([[0, 0],\n" +
                "       [1, 1],\n" +
                "       [2, 0],\n" +
                "       [2, 1]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);

            // A common use for nonzero is to find the indices of an array, where
            // a condition is True.  Given an array a, the condition a > 3 is a
            // boolean array and since False is interpreted as 0, cp.nonzero(a > 3)
            // yields the indices of the a where the condition is true.

            // >>> a = cp.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            // >>> a > 3
            // array([[False, False, False],
            //        [ True,  True,  True],
            //        [ True,  True,  True]])
            // >>> cp.nonzero(a > 3)
            // (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
            // 
            var a = cp.array(new[,] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } });
            given = a > 3;
            expected =
                "array([[False, False, False],\n" +
                "       [ True,  True,  True],\n" +
                "       [ True,  True,  True]])";
            Assert.AreEqual(expected, given.repr);
            given1 = (a > 3).nonzero();
            expected =
                "(array([1, 1, 1, 2, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2], dtype=int64))";
            Assert.AreEqual(expected, given1.repr());

            // Using this result to index a is equivalent to using the mask directly:

            // >>> a[cp.nonzero(a > 3)]
            // array([4, 5, 6, 7, 8, 9])
            // >>> a[a > 3]  # prefer this spelling
            // array([4, 5, 6, 7, 8, 9])
            // 
            given = a[(a > 3).nonzero()];
            expected =
                "array([4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
            given = a[a > 3]; // prefer this spelling
            expected =
                "array([4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);


            // nonzero can also be called as a method of the array.

            // >>> (a > 3).nonzero()
            // (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
            // 
            given1 = (a > 3).nonzero();
            expected =
                "(array([1, 1, 1, 2, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2], dtype=int64))";
            Assert.AreEqual(expected, given1.repr());
        }


        [Test]
        public void whereTest()
        {
            // >>> a = cp.arange(10)
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> cp.where(a < 5, a, 10*a)
            // array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
            // 

            var a = cp.arange(10);
            var given = a;
            var expected =
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
            given = (a < 5).where(a, 10 * a);
            expected =
                "array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])";
            Assert.AreEqual(expected, given.repr);

            // This can be used on multidimensional arrays too:

            // >>> cp.where([[True, False], [True, True]],
            // ...          [[1, 2], [3, 4]],
            // ...          [[9, 8], [7, 6]])
            // array([[1, 8],
            //        [3, 4]])
            // 

            given = cp.array(new[,] { { true, false }, { true, true } }).where(cp.array(new[,] { { 1, 2 }, { 3, 4 } }),
                cp.array(new[,] { { 9, 8 }, { 7, 6 } }));
            expected =
                "array([[1, 8],\n" +
                "       [3, 4]])";
            Assert.AreEqual(expected, given.repr);

            // The shapes of x, y, and the condition are broadcast together:

            // >>> x, y = cp.ogrid[:3, :4]
            // >>> cp.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
            // array([[10,  0,  0,  0],
            //        [10, 11,  1,  1],
            //        [10, 11, 12,  2]])
            // 

            // TODO: implement cp.ogrid !
#if TODO
             given = x, y = cp.ogrid{:3, :4};
             given = cp.where(x < y, x, 10 + y)  # both x and 10+y are broadcast;
             expected =
                "array([[10,  0,  0,  0],\n" +
                "       [10, 11,  1,  1],\n" +
                "       [10, 11, 12,  2]])";
            Assert.AreEqual(expected, given.repr);
#endif

            // >>> a = cp.array([[0, 1, 2],
            // ...               [0, 2, 4],
            // ...               [0, 3, 6]])
            // >>> cp.where(a < 4, a, -1)  # -1 is broadcast
            // array([[ 0,  1,  2],
            //        [ 0,  2, -1],
            //        [ 0,  3, -1]])
            // 


            a = cp.array(new[,] { { 0, 1, 2 }, { 0, 2, 4 }, { 0, 3, 6 } });
            given = (a < 4).where(a, cp.array(-1)); // -1 is broadcast;
            expected =
                "array([[ 0,  1,  2],\n" +
                "       [ 0,  2, -1],\n" +
                "       [ 0,  3, -1]])";
            Assert.AreEqual(expected, given.repr);
        }


        [Test]
        public void indicesTest()
        {
            // >>> grid = cp.indices((2, 3))
            // >>> grid.shape
            // (2, 2, 3)
            // >>> grid[0]        # row indices
            // array([[0, 0, 0],
            //        [1, 1, 1]])
            // >>> grid[1]        # column indices
            // array([[0, 1, 2],
            //        [0, 1, 2]])
            // 

#if TODO
            var given = grid = cp.indices((2, 3));
             given = grid.shape;
            var expected =
                "(2, 2, 3)";
            Assert.AreEqual(expected, given.repr);
             given = grid[0]        # row indices;
             expected =
                "array([[0, 0, 0],\n" +
                "       [1, 1, 1]])";
            Assert.AreEqual(expected, given.repr);
             given = grid[1]        # column indices;
             expected =
                "array([[0, 1, 2],\n" +
                "       [0, 1, 2]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The indices can be used as an index into an array.

            // >>> x = cp.arange(20).reshape(5, 4)
            // >>> row, col = cp.indices((2, 3))
            // >>> x[row, col]
            // array([[0, 1, 2],
            //        [4, 5, 6]])
            // 

#if TODO
             given = x = cp.arange(20).reshape(5, 4);
             given = row, col = cp.indices((2, 3));
             given = x[row, col];
             expected =
                "array([[0, 1, 2],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note that it would be more straightforward in the above example to
            // extract the required elements directly with x[:2, :3].
        }


        [Test]
        public void ix_Test()
        {
            // >>> a = cp.arange(10).reshape(2, 5)
            // >>> a
            // array([[0, 1, 2, 3, 4],
            //        [5, 6, 7, 8, 9]])
            // >>> ixgrid = cp.ix_([0, 1], [2, 4])
            // >>> ixgrid
            // (array([[0],
            //        [1]]), array([[2, 4]]))
            // >>> ixgrid[0].shape, ixgrid[1].shape
            // ((2, 1), (1, 2))
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // 

#if TODO
            var given = a = cp.arange(10).reshape(2, 5);
             given = a;
            var expected =
                "array([[0, 1, 2, 3, 4],\n" +
                "       [5, 6, 7, 8, 9]])";
            Assert.AreEqual(expected, given.repr);
             given = ixgrid = cp.ix_({0, 1}, {2, 4});
             given = ixgrid;
             expected =
                "(array([[0],\n" +
                "       [1]]), array([[2, 4]]))";
            Assert.AreEqual(expected, given.repr);
             given = ixgrid[0].shape, ixgrid[1].shape;
             expected =
                "((2, 1), (1, 2))";
            Assert.AreEqual(expected, given.repr);
             given = a[ixgrid];
             expected =
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> ixgrid = cp.ix_([True, True], [2, 4])
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // >>> ixgrid = cp.ix_([True, True], [False, False, True, False, True])
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // 

#if TODO
             given = ixgrid = cp.ix_({True, True}, {2, 4});
             given = a[ixgrid];
             expected =
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
             given = ixgrid = cp.ix_({True, True}, {False, False, True, False, True});
             given = a[ixgrid];
             expected =
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void ravel_multi_indexTest()
        {
            // >>> arr = cp.array([[3,6,6],[4,5,1]])
            // >>> cp.ravel_multi_index(arr, (7,6))
            // array([22, 41, 37])
            // >>> cp.ravel_multi_index(arr, (7,6), order='F')
            // array([31, 41, 13])
            // >>> cp.ravel_multi_index(arr, (4,6), mode='clip')
            // array([22, 23, 19])
            // >>> cp.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
            // array([12, 13, 13])
            // 

#if TODO
            var given = arr = cp.array({{3,6,6},{4,5,1}});
             given = cp.ravel_multi_index(arr, (7,6));
            var expected =
                "array([22, 41, 37])";
            Assert.AreEqual(expected, given.repr);
             given = cp.ravel_multi_index(arr, (7,6), order = 'F');
             expected =
                "array([31, 41, 13])";
            Assert.AreEqual(expected, given.repr);
             given = cp.ravel_multi_index(arr, (4,6), mode = 'clip');
             expected =
                "array([22, 23, 19])";
            Assert.AreEqual(expected, given.repr);
             given = cp.ravel_multi_index(arr, (4,4), mode = ('clip','wrap'));
             expected =
                "array([12, 13, 13])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.ravel_multi_index((3,1,4,1), (6,7,8,9))
            // 1621
            // 

#if TODO
             given = cp.ravel_multi_index((3,1,4,1), (6,7,8,9));
             expected =
                "1621";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void unravel_indexTest()
        {
            // >>> cp.unravel_index([22, 41, 37], (7,6))
            // (array([3, 6, 6]), array([4, 5, 1]))
            // >>> cp.unravel_index([31, 41, 13], (7,6), order='F')
            // (array([3, 6, 6]), array([4, 5, 1]))
            // 

#if TODO
            var given = cp.unravel_index({22, 41, 37}, (7,6));
            var expected =
                "(array([3, 6, 6]), array([4, 5, 1]))";
            Assert.AreEqual(expected, given.repr);
             given = cp.unravel_index({31, 41, 13}, (7,6), order = 'F');
             expected =
                "(array([3, 6, 6]), array([4, 5, 1]))";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.unravel_index(1621, (6,7,8,9))
            // (3, 1, 4, 1)
            // 

#if TODO
             given = cp.unravel_index(1621, (6,7,8,9));
             expected =
                "(3, 1, 4, 1)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void diag_indicesTest()
        {
            // Create a set of indices to access the diagonal of a (4, 4) array:

            // >>> di = cp.diag_indices(4)
            // >>> di
            // (array([0, 1, 2, 3]), array([0, 1, 2, 3]))
            // >>> a = cp.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // >>> a[di] = 100
            // >>> a
            // array([[100,   1,   2,   3],
            //        [  4, 100,   6,   7],
            //        [  8,   9, 100,  11],
            //        [ 12,  13,  14, 100]])
            // 

#if TODO
            var given = di = cp.diag_indices(4);
             given = di;
            var expected =
                "(array([0, 1, 2, 3]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
             given = a = cp.arange(16).reshape(4, 4);
             given = a;
             expected =
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
             given = a[di] = 100;
             given = a;
             expected =
                "array([[100,   1,   2,   3],\n" +
                "       [  4, 100,   6,   7],\n" +
                "       [  8,   9, 100,  11],\n" +
                "       [ 12,  13,  14, 100]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Now, we create indices to manipulate a 3-D array:

            // >>> d3 = cp.diag_indices(2, 3)
            // >>> d3
            // (array([0, 1]), array([0, 1]), array([0, 1]))
            // 

#if TODO
             given = d3 = cp.diag_indices(2, 3);
             given = d3;
             expected =
                "(array([0, 1]), array([0, 1]), array([0, 1]))";
            Assert.AreEqual(expected, given.repr);
#endif
            // And use it to set the diagonal of an array of zeros to 1:

            // >>> a = cp.zeros((2, 2, 2), dtype=int)
            // >>> a[d3] = 1
            // >>> a
            // array([[[1, 0],
            //         [0, 0]],
            //        [[0, 0],
            //         [0, 1]]])
            // 

#if TODO
             given = a = cp.zeros((2, 2, 2), dtype = int);
             given = a[d3] = 1;
             given = a;
             expected =
                "array([[[1, 0],\n" +
                "        [0, 0]],\n" +
                "       [[0, 0],\n" +
                "        [0, 1]]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void mask_indicesTest()
        {
            // These are the indices that would allow you to access the upper triangular
            // part of any 3x3 array:

            // >>> iu = cp.mask_indices(3, cp.triu)
            // 

#if TODO
            var given = iu = cp.mask_indices(3, cp.triu);
#endif
            // For example, if a is a 3x3 array:

            // >>> a = cp.arange(9).reshape(3, 3)
            // >>> a
            // array([[0, 1, 2],
            //        [3, 4, 5],
            //        [6, 7, 8]])
            // >>> a[iu]
            // array([0, 1, 2, 4, 5, 8])
            // 

#if TODO
             given = a = cp.arange(9).reshape(3, 3);
             given = a;
            var expected =
                "array([[0, 1, 2],\n" +
                "       [3, 4, 5],\n" +
                "       [6, 7, 8]])";
            Assert.AreEqual(expected, given.repr);
             given = a[iu];
             expected =
                "array([0, 1, 2, 4, 5, 8])";
            Assert.AreEqual(expected, given.repr);
#endif
            // An offset can be passed also to the masking function.  This gets us the
            // indices starting on the first diagonal right of the main one:

            // >>> iu1 = cp.mask_indices(3, cp.triu, 1)
            // 

#if TODO
             given = iu1 = cp.mask_indices(3, cp.triu, 1);
#endif
            // with which we now extract only three elements:

            // >>> a[iu1]
            // array([1, 2, 5])
            // 

#if TODO
             given = a[iu1];
             expected =
                "array([1, 2, 5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void tril_indicesTest()
        {
            // Compute two different sets of indices to access 4x4 arrays, one for the
            // lower triangular part starting at the main diagonal, and one starting two
            // diagonals further right:

            // >>> il1 = cp.tril_indices(4)
            // >>> il2 = cp.tril_indices(4, 2)
            // 

#if TODO
            var given = il1 = cp.tril_indices(4);
             given = il2 = cp.tril_indices(4, 2);
#endif
            // Here is how they can be used with a sample array:

            // >>> a = cp.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // 

#if TODO
             given = a = cp.arange(16).reshape(4, 4);
             given = a;
            var expected =
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Both for indexing:

            // >>> a[il1]
            // array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])
            // 

#if TODO
             given = a[il1];
             expected =
                "array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])";
            Assert.AreEqual(expected, given.repr);
#endif
            // And for assigning values:

            // >>> a[il1] = -1
            // >>> a
            // array([[-1,  1,  2,  3],
            //        [-1, -1,  6,  7],
            //        [-1, -1, -1, 11],
            //        [-1, -1, -1, -1]])
            // 

#if TODO
             given = a[il1] = -1;
             given = a;
             expected =
                "array([[-1,  1,  2,  3],\n" +
                "       [-1, -1,  6,  7],\n" +
                "       [-1, -1, -1, 11],\n" +
                "       [-1, -1, -1, -1]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // These cover almost the whole array (two diagonals right of the main one):

            // >>> a[il2] = -10
            // >>> a
            // array([[-10, -10, -10,   3],
            //        [-10, -10, -10, -10],
            //        [-10, -10, -10, -10],
            //        [-10, -10, -10, -10]])
            // 

#if TODO
             given = a[il2] = -10;
             given = a;
             expected =
                "array([[-10, -10, -10,   3],\n" +
                "       [-10, -10, -10, -10],\n" +
                "       [-10, -10, -10, -10],\n" +
                "       [-10, -10, -10, -10]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void triu_indicesTest()
        {
            // Compute two different sets of indices to access 4x4 arrays, one for the
            // upper triangular part starting at the main diagonal, and one starting two
            // diagonals further right:

            // >>> iu1 = cp.triu_indices(4)
            // >>> iu2 = cp.triu_indices(4, 2)
            // 

#if TODO
            var given = iu1 = cp.triu_indices(4);
             given = iu2 = cp.triu_indices(4, 2);
#endif
            // Here is how they can be used with a sample array:

            // >>> a = cp.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // 

#if TODO
             given = a = cp.arange(16).reshape(4, 4);
             given = a;
            var expected =
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Both for indexing:

            // >>> a[iu1]
            // array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])
            // 

#if TODO
             given = a[iu1];
             expected =
                "array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])";
            Assert.AreEqual(expected, given.repr);
#endif
            // And for assigning values:

            // >>> a[iu1] = -1
            // >>> a
            // array([[-1, -1, -1, -1],
            //        [ 4, -1, -1, -1],
            //        [ 8,  9, -1, -1],
            //        [12, 13, 14, -1]])
            // 

#if TODO
             given = a[iu1] = -1;
             given = a;
             expected =
                "array([[-1, -1, -1, -1],\n" +
                "       [ 4, -1, -1, -1],\n" +
                "       [ 8,  9, -1, -1],\n" +
                "       [12, 13, 14, -1]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // These cover only a small part of the whole array (two diagonals right
            // of the main one):

            // >>> a[iu2] = -10
            // >>> a
            // array([[ -1,  -1, -10, -10],
            //        [  4,  -1,  -1, -10],
            //        [  8,   9,  -1,  -1],
            //        [ 12,  13,  14,  -1]])
            // 

#if TODO
             given = a[iu2] = -10;
             given = a;
             expected =
                "array([[ -1,  -1, -10, -10],\n" +
                "       [  4,  -1,  -1, -10],\n" +
                "       [  8,   9,  -1,  -1],\n" +
                "       [ 12,  13,  14,  -1]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void takeTest()
        {
            // >>> a = [4, 3, 5, 7, 6, 8]
            // >>> indices = [0, 1, 4]
            // >>> cp.take(a, indices)
            // array([4, 3, 6])
            // 

#if TODO
            var given = a = [4, 3, 5, 7, 6, 8];
             given = indices = [0, 1, 4];
             given = cp.take(a, indices);
            var expected =
                "array([4, 3, 6])";
            Assert.AreEqual(expected, given.repr);
#endif
            // In this example if a is an ndarray, “fancy” indexing can be used.

            // >>> a = cp.array(a)
            // >>> a[indices]
            // array([4, 3, 6])
            // 

#if TODO
             given = a = cp.array(a);
             given = a[indices];
             expected =
                "array([4, 3, 6])";
            Assert.AreEqual(expected, given.repr);
#endif
            // If indices is not one dimensional, the output also has these dimensions.

            // >>> cp.take(a, [[0, 1], [2, 3]])
            // array([[4, 3],
            //        [5, 7]])
            // 

#if TODO
             given = cp.take(a, {{0, 1}, {2, 3}});
             expected =
                "array([[4, 3],\n" +
                "       [5, 7]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void take_along_axisTest()
        {
            // For this sample array

            // >>> a = cp.array([[10, 30, 20], [60, 40, 50]])
            var a = cp.array(new[,] { { 10, 30, 20 }, { 60, 40, 50 } });

            // We can sort either by using sort directly, or argsort and this function

            // >>> cp.sort(a, axis=1)
            // array([[10, 20, 30],
            //        [40, 50, 60]])
            // >>> ai = cp.argsort(a, axis=1); ai
            // array([[0, 2, 1],
            //        [1, 2, 0]], dtype=int64)
            // >>> cp.take_along_axis(a, ai, axis=1)
            // array([[10, 20, 30],
            //        [40, 50, 60]])
            // 

            var given = a.sort(1);
            var expected =
                "array([[10, 20, 30],\n" +
                "       [40, 50, 60]])";
            Assert.AreEqual(expected, given.repr);
            var ai = a.argsort(1);
            given = ai;
            expected =
                "array([[0, 2, 1],\n" +
                "       [1, 2, 0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
            given = a.take_along_axis(ai, 1);
            expected =
                "array([[10, 20, 30],\n" +
                "       [40, 50, 60]])";
            Assert.AreEqual(expected, given.repr);

            // The same works for max and min, if you expand the dimensions:

            // >>> cp.expand_dims(cp.max(a, axis=1), axis=1)
            // array([[30],
            //        [60]])
            // >>> ai = cp.expand_dims(cp.argmax(a, axis=1), axis=1)
            // >>> ai
            // array([[1],
            //        [0], dtype=int64)
            // >>> cp.take_along_axis(a, ai, axis=1)
            // array([[30],
            //        [60]])
            // 

            given = cp.max(a, new[] { 1 }).expand_dims(1);
            expected =
                "array([[30],\n" +
                "       [60]])";
            Assert.AreEqual(expected, given.repr);
            given = ai = a.argmax(1).expand_dims(1);
            given = ai;
            expected =
                "array([[1],\n" +
                "       [0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
            given = a.take_along_axis(ai, 1);
            expected =
                "array([[30],\n" +
                "       [60]])";
            Assert.AreEqual(expected, given.repr);

            // If we want to get the max and min at the same time, we can stack the
            // indices first

            // >>> ai_min = cp.expand_dims(cp.argmin(a, axis=1), axis=1)
            // >>> ai_max = cp.expand_dims(cp.argmax(a, axis=1), axis=1)
            // >>> ai = cp.concatenate([ai_min, ai_max], axis=axis)
            // >> ai
            // array([[0, 1],
            //        [1, 0]], dtype=int64)
            // >>> cp.take_along_axis(a, ai, axis=1)
            // array([[10, 30],
            //        [40, 60]])
            // 

            var ai_min = a.argmin(1).expand_dims(1);
            var ai_max = a.argmax(1).expand_dims(1);
            given = ai = cp.concatenate(new[] { ai_min, ai_max }, 1);
            expected =
                "array([[0, 1],\n" +
                "       [1, 0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
            given = a.take_along_axis(ai, 1);
            expected =
                "array([[10, 30],\n" +
                "       [40, 60]])";
            Assert.AreEqual(expected, given.repr);
        }


        [Test]
        public void chooseTest()
        {
            // >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
            // ...   [20, 21, 22, 23], [30, 31, 32, 33]]
            // >>> cp.choose([2, 3, 1, 0], choices
            // ... # the first element of the result will be the first element of the
            // ... # third (2+1) "array" in choices, namely, 20; the second element
            // ... # will be the second element of the fourth (3+1) choice array, i.e.,
            // ... # 31, etc.
            // ... )
            // array([20, 31, 12,  3])
            // >>> cp.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
            // array([20, 31, 12,  3])
            // >>> # because there are 4 choice arrays
            // >>> cp.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
            // array([20,  1, 12,  3])
            // >>> # i.e., 0
            // 

#if TODO
            var given = choices = [[0, 1, 2, 3], [10, 11, 12, 13],;
            var expected =
                "...   [20, 21, 22, 23], [30, 31, 32, 33]]";
            Assert.AreEqual(expected, given.repr);
             given = cp.choose({2, 3, 1, 0}, choices;
             expected =
                "... # the first element of the result will be the first element of the\n" +
                "... # third (2+1) "array" in choices, namely, 20; the second element\n" +
                "... # will be the second element of the fourth (3+1) choice array, i.e.,\n" +
                "... # 31, etc.\n" +
                "... )\n" +
                "array([20, 31, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given = cp.choose({2, 4, 1, 0}, choices, mode = 'clip') # 4 goes to 3 (4-1);
             expected =
                "array([20, 31, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given = # because there are 4 choice arrays;
             given = cp.choose({2, 4, 1, 0}, choices, mode = 'wrap') # 4 goes to (4 mod 4);
             expected =
                "array([20,  1, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given = # i.e., 0;
#endif
            // A couple examples illustrating how choose broadcasts:

            // >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
            // >>> choices = [-10, 10]
            // >>> cp.choose(a, choices)
            // array([[ 10, -10,  10],
            //        [-10,  10, -10],
            //        [ 10, -10,  10]])
            // 

#if TODO
             given = a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]];
             given = choices = [-10, 10];
             given = cp.choose(a, choices);
             expected =
                "array([[ 10, -10,  10],\n" +
                "       [-10,  10, -10],\n" +
                "       [ 10, -10,  10]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # With thanks to Anne Archibald
            // >>> a = cp.array([0, 1]).reshape((2,1,1))
            // >>> c1 = cp.array([1, 2, 3]).reshape((1,3,1))
            // >>> c2 = cp.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
            // >>> cp.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
            // array([[[ 1,  1,  1,  1,  1],
            //         [ 2,  2,  2,  2,  2],
            //         [ 3,  3,  3,  3,  3]],
            //        [[-1, -2, -3, -4, -5],
            //         [-1, -2, -3, -4, -5],
            //         [-1, -2, -3, -4, -5]]])
            // 

#if TODO
             given = # With thanks to Anne Archibald;
             given = a = cp.array({0, 1}).reshape((2,1,1));
             given = c1 = cp.array({1, 2, 3}).reshape((1,3,1));
             given = c2 = cp.array({-1, -2, -3, -4, -5}).reshape((1,1,5));
             given = cp.choose(a, (c1, c2)) # result is 2x3x5, res{0,:,:} = c1, res{1,:,:} = c2;
             expected =
                "array([[[ 1,  1,  1,  1,  1],\n" +
                "        [ 2,  2,  2,  2,  2],\n" +
                "        [ 3,  3,  3,  3,  3]],\n" +
                "       [[-1, -2, -3, -4, -5],\n" +
                "        [-1, -2, -3, -4, -5],\n" +
                "        [-1, -2, -3, -4, -5]]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void compressTest()
        {
            // >>> a = cp.array([[1, 2], [3, 4], [5, 6]])
            // >>> a
            // array([[1, 2],
            //        [3, 4],
            //        [5, 6]])
            // >>> cp.compress([0, 1], a, axis=0)
            // array([[3, 4]])
            // >>> cp.compress([False, True, True], a, axis=0)
            // array([[3, 4],
            //        [5, 6]])
            // >>> cp.compress([False, True], a, axis=1)
            // array([[2],
            //        [4],
            //        [6]])
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, 4}, {5, 6}});
             given = a;
            var expected =
                "array([[1, 2],\n" +
                "       [3, 4],\n" +
                "       [5, 6]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.compress({0, 1}, a, axis = 0);
             expected =
                "array([[3, 4]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.compress({False, True, True}, a, axis = 0);
             expected =
                "array([[3, 4],\n" +
                "       [5, 6]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.compress({False, True}, a, axis = 1);
             expected =
                "array([[2],\n" +
                "       [4],\n" +
                "       [6]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Working on the flattened array does not return slices along an axis but
            // selects elements.

            // >>> cp.compress([False, True], a)
            // array([2])
            // 

#if TODO
             given = cp.compress({False, True}, a);
             expected =
                "array([2])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void diagonalTest()
        {
            // >>> a = cp.arange(4).reshape(2,2)
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> a.diagonal()
            // array([0, 3])
            // >>> a.diagonal(1)
            // array([1])
            // 

#if TODO
            var given = a = cp.arange(4).reshape(2,2);
             given = a;
            var expected =
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
             given = a.diagonal();
             expected =
                "array([0, 3])";
            Assert.AreEqual(expected, given.repr);
             given = a.diagonal(1);
             expected =
                "array([1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // A 3-D example:

            // >>> a = cp.arange(8).reshape(2,2,2); a
            // array([[[0, 1],
            //         [2, 3]],
            //        [[4, 5],
            //         [6, 7]]])
            // >>> a.diagonal(0, # Main diagonals of two arrays created by skipping
            // ...            0, # across the outer(left)-most axis last and
            // ...            1) # the "middle" (row) axis first.
            // array([[0, 6],
            //        [1, 7]])
            // 

#if TODO
             given = a = cp.arange(8).reshape(2,2,2); a;
             expected =
                "array([[[0, 1],\n" +
                "        [2, 3]],\n" +
                "       [[4, 5],\n" +
                "        [6, 7]]])";
            Assert.AreEqual(expected, given.repr);
             given = a.diagonal(0, # Main diagonals of two arrays created by skipping;
             expected =
                "...            0, # across the outer(left)-most axis last and\n" +
                "...            1) # the "middle" (row) axis first.\n" +
                "array([[0, 6],\n" +
                "       [1, 7]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The sub-arrays whose main diagonals we just obtained; note that each
            // corresponds to fixing the right-most (column) axis, and that the
            // diagonals are “packed” in rows.

            // >>> a[:,:,0] # main diagonal is [0 6]
            // array([[0, 2],
            //        [4, 6]])
            // >>> a[:,:,1] # main diagonal is [1 7]
            // array([[1, 3],
            //        [5, 7]])
            // 

#if TODO
             given = a[:,:,0] # main diagonal is [0 6];
             expected =
                "array([[0, 2],\n" +
                "       [4, 6]])";
            Assert.AreEqual(expected, given.repr);
             given = a[:,:,1] # main diagonal is [1 7];
             expected =
                "array([[1, 3],\n" +
                "       [5, 7]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void selectTest()
        {
            // >>> x = cp.arange(10)
            // >>> condlist = [x<3, x>5]
            // >>> choicelist = [x, x**2]
            // >>> cp.select(condlist, choicelist)
            // array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])
            // 

#if TODO
            var given = x = cp.arange(10);
             given = condlist = [x<3, x>5];
             given = choicelist = [x, x**2];
             given = cp.select(condlist, choicelist);
            var expected =
                "array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void placeTest()
        {
            // >>> arr = cp.arange(6).reshape(2, 3)
            // >>> cp.place(arr, arr>2, [44, 55])
            // >>> arr
            // array([[ 0,  1,  2],
            //        [44, 55, 44]])
            // 

#if TODO
            var given = arr = cp.arange(6).reshape(2, 3);
             given = cp.place(arr, arr>2, {44, 55});
             given = arr;
            var expected =
                "array([[ 0,  1,  2],\n" +
                "       [44, 55, 44]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void putTest()
        {
            // >>> a = cp.arange(5)
            // >>> cp.put(a, [0, 2], [-44, -55])
            // >>> a
            // array([-44,   1, -55,   3,   4])
            // 

#if TODO
            var given = a = cp.arange(5);
             given = cp.put(a, {0, 2}, {-44, -55});
             given = a;
            var expected =
                "array([-44,   1, -55,   3,   4])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.arange(5)
            // >>> cp.put(a, 22, -5, mode='clip')
            // >>> a
            // array([ 0,  1,  2,  3, -5])
            // 

#if TODO
             given = a = cp.arange(5);
             given = cp.put(a, 22, -5, mode = 'clip');
             given = a;
             expected =
                "array([ 0,  1,  2,  3, -5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void put_along_axisTest()
        {
            // For this sample array

            // >>> a = cp.array([[10, 30, 20], [60, 40, 50]])
            // 

#if TODO
            var given = a = cp.array({{10, 30, 20}, {60, 40, 50}});
#endif
            // We can replace the maximum values with:

            // >>> ai = cp.expand_dims(cp.argmax(a, axis=1), axis=1)
            // >>> ai
            // array([[1],
            //        [0]], dtype=int64)
            // >>> cp.put_along_axis(a, ai, 99, axis=1)
            // >>> a
            // array([[10, 99, 20],
            //        [99, 40, 50]])
            // 

#if TODO
             given = ai = cp.expand_dims(cp.argmax(a, axis = 1), axis = 1);
             given = ai;
            var expected =
                "array([[1],\n" +
                "       [0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
             given = cp.put_along_axis(a, ai, 99, axis = 1);
             given = a;
             expected =
                "array([[10, 99, 20],\n" +
                "       [99, 40, 50]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void putmaskTest()
        {
            // >>> x = cp.arange(6).reshape(2, 3)
            // >>> cp.putmask(x, x>2, x**2)
            // >>> x
            // array([[ 0,  1,  2],
            //        [ 9, 16, 25]])
            // 

#if TODO
            var given = x = cp.arange(6).reshape(2, 3);
             given = cp.putmask(x, x>2, x**2);
             given = x;
            var expected =
                "array([[ 0,  1,  2],\n" +
                "       [ 9, 16, 25]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // If values is smaller than a it is repeated:

            // >>> x = cp.arange(5)
            // >>> cp.putmask(x, x>1, [-33, -44])
            // >>> x
            // array([  0,   1, -33, -44, -33])
            // 

#if TODO
             given = x = cp.arange(5);
             given = cp.putmask(x, x>1, {-33, -44});
             given = x;
             expected =
                "array([  0,   1, -33, -44, -33])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void fill_diagonalTest()
        {
            // >>> a = cp.zeros((3, 3), int)
            // >>> cp.fill_diagonal(a, 5)
            // >>> a
            // array([[5, 0, 0],
            //        [0, 5, 0],
            //        [0, 0, 5]])
            // 

#if TODO
            var given = a = cp.zeros((3, 3), int);
             given = cp.fill_diagonal(a, 5);
             given = a;
            var expected =
                "array([[5, 0, 0],\n" +
                "       [0, 5, 0],\n" +
                "       [0, 0, 5]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The same function can operate on a 4-D array:

            // >>> a = cp.zeros((3, 3, 3, 3), int)
            // >>> cp.fill_diagonal(a, 4)
            // 

#if TODO
             given = a = cp.zeros((3, 3, 3, 3), int);
             given = cp.fill_diagonal(a, 4);
#endif
            // We only show a few blocks for clarity:

            // >>> a[0, 0]
            // array([[4, 0, 0],
            //        [0, 0, 0],
            //        [0, 0, 0]])
            // >>> a[1, 1]
            // array([[0, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 0]])
            // >>> a[2, 2]
            // array([[0, 0, 0],
            //        [0, 0, 0],
            //        [0, 0, 4]])
            // 

#if TODO
             given = a[0, 0];
             expected =
                "array([[4, 0, 0],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
             given = a[1, 1];
             expected =
                "array([[0, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
             given = a[2, 2];
             expected =
                "array([[0, 0, 0],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 4]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The wrap option affects only tall matrices:

            // >>> # tall matrices no wrap
            // >>> a = cp.zeros((5, 3),int)
            // >>> fill_diagonal(a, 4)
            // >>> a
            // array([[4, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 4],
            //        [0, 0, 0],
            //        [0, 0, 0]])
            // 

#if TODO
             given = # tall matrices no wrap;
             given = a = cp.zeros((5, 3),int);
             given = fill_diagonal(a, 4);
             given = a;
             expected =
                "array([[4, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 4],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # tall matrices wrap
            // >>> a = cp.zeros((5, 3),int)
            // >>> fill_diagonal(a, 4, wrap=True)
            // >>> a
            // array([[4, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 4],
            //        [0, 0, 0],
            //        [4, 0, 0]])
            // 

#if TODO
             given = # tall matrices wrap;
             given = a = cp.zeros((5, 3),int);
             given = fill_diagonal(a, 4, wrap = True);
             given = a;
             expected =
                "array([[4, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 4],\n" +
                "       [0, 0, 0],\n" +
                "       [4, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # wide matrices
            // >>> a = cp.zeros((3, 5),int)
            // >>> fill_diagonal(a, 4, wrap=True)
            // >>> a
            // array([[4, 0, 0, 0, 0],
            //        [0, 4, 0, 0, 0],
            //        [0, 0, 4, 0, 0]])
            // 

#if TODO
             given = # wide matrices;
             given = a = cp.zeros((3, 5),int);
             given = fill_diagonal(a, 4, wrap = True);
             given = a;
             expected =
                "array([[4, 0, 0, 0, 0],\n" +
                "       [0, 4, 0, 0, 0],\n" +
                "       [0, 0, 4, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nditerTest()
        {
            // Here is how we might write an iter_add function, using the
            // Python iterator protocol:

            // def iter_add_py(x, y, out=None):
            //     addop = cp.add
            //     it = cp.nditer([x, y, out], [],
            //                 [['readonly'], ['readonly'], ['writeonly','allocate']])
            //     with it:
            //         for (a, b, c) in it:
            //             addop(a, b, out=c)
            //     return it.operands[2]
            // 

#if TODO
            var expected =
                "def iter_add_py(x, y, out=None):\n" +
                "    addop = cp.add\n" +
                "    it = cp.nditer([x, y, out], [],\n" +
                "                [['readonly'], ['readonly'], ['writeonly','allocate']])\n" +
                "    with it:\n" +
                "        for (a, b, c) in it:\n" +
                "            addop(a, b, out=c)\n" +
                "    return it.operands[2]";
            Assert.AreEqual(expected, given.repr);
#endif
            // Here is the same function, but following the C-style pattern:

            // def iter_add(x, y, out=None):
            //     addop = cp.add
            // 
            //     it = cp.nditer([x, y, out], [],
            //                 [['readonly'], ['readonly'], ['writeonly','allocate']])
            //     with it:
            //         while not it.finished:
            //             addop(it[0], it[1], out=it[2])
            //             it.iternext()
            // 
            //         return it.operands[2]
            // 

#if TODO
             expected =
                "def iter_add(x, y, out=None):\n" +
                "    addop = cp.add\n" +
                "\n" +
                "    it = cp.nditer([x, y, out], [],\n" +
                "                [['readonly'], ['readonly'], ['writeonly','allocate']])\n" +
                "    with it:\n" +
                "        while not it.finished:\n" +
                "            addop(it[0], it[1], out=it[2])\n" +
                "            it.iternext()\n" +
                "\n" +
                "        return it.operands[2]";
            Assert.AreEqual(expected, given.repr);
#endif
            // Here is an example outer product function:

            // def outer_it(x, y, out=None):
            //     mulop = cp.multiply
            // 
            //     it = cp.nditer([x, y, out], ['external_loop'],
            //             [['readonly'], ['readonly'], ['writeonly', 'allocate']],
            //             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,
            //                      [-1] * x.ndim + list(range(y.ndim)),
            //                      None])
            //     with it:
            //         for (a, b, c) in it:
            //             mulop(a, b, out=c)
            //         return it.operands[2]
            // 
            // >>> a = cp.arange(2)+1
            // >>> b = cp.arange(3)+1
            // >>> outer_it(a,b)
            // array([[1, 2, 3],
            //        [2, 4, 6]])
            // 

#if TODO
             expected =
                "def outer_it(x, y, out=None):\n" +
                "    mulop = cp.multiply\n" +
                "\n" +
                "    it = cp.nditer([x, y, out], ['external_loop'],\n" +
                "            [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n" +
                "            op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n" +
                "                     [-1] * x.ndim + list(range(y.ndim)),\n" +
                "                     None])\n" +
                "    with it:\n" +
                "        for (a, b, c) in it:\n" +
                "            mulop(a, b, out=c)\n" +
                "        return it.operands[2]\n" +
                "";
            Assert.AreEqual(expected, given.repr);
            var given = a = cp.arange(2)+1;
             given = b = cp.arange(3)+1;
             given = outer_it(a,b);
             expected =
                "array([[1, 2, 3],\n" +
                "       [2, 4, 6]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Here is an example function which operates like a “lambda” ufunc:

            // def luf(lamdaexpr, *args, **kwargs):
            //     "luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)"
            //     nargs = len(args)
            //     op = (kwargs.get('out',None),) + args
            //     it = cp.nditer(op, ['buffered','external_loop'],
            //             [['writeonly','allocate','no_broadcast']] +
            //                             [['readonly','nbo','aligned']]*nargs,
            //             order=kwargs.get('order','K'),
            //             casting=kwargs.get('casting','safe'),
            //             buffersize=kwargs.get('buffersize',0))
            //     while not it.finished:
            //         it[0] = lamdaexpr(*it[1:])
            //         it.iternext()
            //         return it.operands[0]
            // 
            // >>> a = cp.arange(5)
            // >>> b = cp.ones(5)
            // >>> luf(lambda i,j:i*i + j/2, a, b)
            // array([  0.5,   1.5,   4.5,   9.5,  16.5])
            // 

#if TODO
             expected =
                "def luf(lamdaexpr, *args, **kwargs):\n" +
                "    "luf(lambdaexpr, op1, ..., opn, out = None, order = 'K', casting = 'safe', buffersize = 0)"\n" +
                "    nargs = len(args)\n" +
                "    op = (kwargs.get('out',None),) + args\n" +
                "    it = cp.nditer(op, ['buffered','external_loop'],\n" +
                "            [['writeonly','allocate','no_broadcast']] +\n" +
                "                            [['readonly','nbo','aligned']]*nargs,\n" +
                "            order=kwargs.get('order','K'),\n" +
                "            casting=kwargs.get('casting','safe'),\n" +
                "            buffersize=kwargs.get('buffersize',0))\n" +
                "    while not it.finished:\n" +
                "        it[0] = lamdaexpr(*it[1:])\n" +
                "        it.iternext()\n" +
                "        return it.operands[0]\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given = a = cp.arange(5);
             given = b = cp.ones(5);
             given = luf(lambda i,j:i*i + j/2, a, b);
             expected =
                "array([  0.5,   1.5,   4.5,   9.5,  16.5])";
            Assert.AreEqual(expected, given.repr);
#endif
            // If operand flags “writeonly” or “readwrite” are used the operands may
            // be views into the original data with the WRITEBACKIFCOPY flag. In this case
            // nditer must be used as a context manager or the nditer.close
            // method must be called before using the result. The temporary
            // data will be written back to the original data when the __exit__
            // function is called but not before:

            // >>> a = cp.arange(6, dtype='i4')[::-2]
            // >>> with nditer(a, [],
            // ...        [['writeonly', 'updateifcopy']],
            // ...        casting='unsafe',
            // ...        op_dtypes=[cp.dtype('f4')]) as i:
            // ...    x = i.operands[0]
            // ...    x[:] = [-1, -2, -3]
            // ...    # a still unchanged here
            // >>> a, x
            // array([-1, -2, -3]), array([-1, -2, -3])
            // 

#if TODO
             given = a = cp.arange(6, dtype = 'i4'){::-2};
             given = with nditer(a, [],;
             expected =
                "...        [['writeonly', 'updateifcopy']],\n" +
                "...        casting='unsafe',\n" +
                "...        op_dtypes=[cp.dtype('f4')]) as i:\n" +
                "...    x = i.operands[0]\n" +
                "...    x[:] = [-1, -2, -3]\n" +
                "...    # a still unchanged here";
            Assert.AreEqual(expected, given.repr);
             given = a, x;
             expected =
                "array([-1, -2, -3]), array([-1, -2, -3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // It is important to note that once the iterator is exited, dangling
            // references (like x in the example) may or may not share data with
            // the original data a. If writeback semantics were active, i.e. if
            // x.base.flags.writebackifcopy is True, then exiting the iterator
            // will sever the connection between x and a, writing to x will
            // no longer write to a. If writeback semantics are not active, then
            // x.data will still point at some part of a.data, and writing to
            // one will affect the other.

            // Methods
        }


        [Test]
        public void ndenumerateTest()
        {
            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> for index, x in cp.ndenumerate(a):
            // ...     print(index, x)
            // (0, 0) 1
            // (0, 1) 2
            // (1, 0) 3
            // (1, 1) 4
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, 4}});
             given = for index, x in cp.ndenumerate(a):;
            var expected =
                "...     print(index, x)\n" +
                "(0, 0) 1\n" +
                "(0, 1) 2\n" +
                "(1, 0) 3\n" +
                "(1, 1) 4";
            Assert.AreEqual(expected, given.repr);
#endif
            // Methods
        }


        [Test]
        public void ndindexTest()
        {
            // >>> for index in cp.ndindex(3, 2, 1):
            // ...     print(index)
            // (0, 0, 0)
            // (0, 1, 0)
            // (1, 0, 0)
            // (1, 1, 0)
            // (2, 0, 0)
            // (2, 1, 0)
            // 

#if TODO
            var given = for index in cp.ndindex(3, 2, 1):;
            var expected =
                "...     print(index)\n" +
                "(0, 0, 0)\n" +
                "(0, 1, 0)\n" +
                "(1, 0, 0)\n" +
                "(1, 1, 0)\n" +
                "(2, 0, 0)\n" +
                "(2, 1, 0)";
            Assert.AreEqual(expected, given.repr);
#endif
            // Methods
        }


        [Test]
        public void nested_itersTest()
        {
            // Basic usage. Note how y is the “flattened” version of
            // [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
            // the first iter’s axes as [1]

            // >>> a = cp.arange(12).reshape(2, 3, 2)
            // >>> i, j = cp.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])
            // >>> for x in i:
            // ...      print(i.multi_index)
            // ...      for y in j:
            // ...          print('', j.multi_index, y)
            // 

#if TODO
            var given = a = cp.arange(12).reshape(2, 3, 2);
             given = i, j = cp.nested_iters(a, {{1}, {0, 2}}, flags = {"multi_index"});
             given = for x in i:;
            var expected =
                "...      print(i.multi_index)\n" +
                "...      for y in j:\n" +
                "...          print('', j.multi_index, y)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void flatiterTest()
        {
            // >>> x = cp.arange(6).reshape(2, 3)
            // >>> fl = x.flat
            // >>> type(fl)
            // <type 'Cupy.flatiter'>
            // >>> for item in fl:
            // ...     print(item)
            // ...
            // 0
            // 1
            // 2
            // 3
            // 4
            // 5
            // 

#if TODO
            var given = x = cp.arange(6).reshape(2, 3);
             given = fl = x.flat;
             given = type(fl);
            var expected =
                "<type 'Cupy.flatiter'>";
            Assert.AreEqual(expected, given.repr);
             given = for item in fl:;
             expected =
                "...     print(item)\n" +
                "...\n" +
                "0\n" +
                "1\n" +
                "2\n" +
                "3\n" +
                "4\n" +
                "5";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> fl[2:4]
            // array([2, 3])
            // 

#if TODO
             given = fl[2:4];
             expected =
                "array([2, 3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = cp.arange(5)
            // >>> fl = x.flat
            // >>> fl.base is x
            // True
            // 

#if TODO
             given = x = cp.arange(5);
             given = fl = x.flat;
             given = fl.base is x;
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // Methods
        }


        [Test]
        public void ArrayteratorTest()
        {
            // >>> a = cp.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)
            // >>> a_itor = cp.lib.Arrayterator(a, 2)
            // >>> a_itor.shape
            // (3, 4, 5, 6)
            // 

#if TODO
            var given = a = cp.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6);
             given = a_itor = cp.lib.Arrayterator(a, 2);
             given = a_itor.shape;
            var expected =
                "(3, 4, 5, 6)";
            Assert.AreEqual(expected, given.repr);
#endif
            // Now we can iterate over a_itor, and it will return arrays of size
            // two. Since buf_size was smaller than any dimension, the first
            // dimension will be iterated over first:

            // >>> for subarr in a_itor:
            // ...     if not subarr.all():
            // ...         print(subarr, subarr.shape)
            // ...
            // [[[[0 1]]]] (1, 1, 1, 2)
            // 

#if TODO
             given = for subarr in a_itor:;
             expected =
                "...     if not subarr.all():\n" +
                "...         print(subarr, subarr.shape)\n" +
                "...\n" +
                "[[[[0 1]]]] (1, 1, 1, 2)";
            Assert.AreEqual(expected, given.repr);
#endif
        }
    }
}