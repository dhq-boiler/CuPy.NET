// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class Cupy_linalgTest : BaseTestCase
    {
        [Test]
        public void dotTest()
        {
            // >>> cp.dot(3, 4)
            // 12
            // 

#if TODO
            var given = cp.dot(3, 4);
            var expected =
                "12";
            Assert.AreEqual(expected, given.repr);
#endif
            // Neither argument is complex-conjugated:

            // >>> cp.dot([2j, 3j], [2j, 3j])
            // (-13+0j)
            // 

#if TODO
             given = cp.dot({2j, 3j}, {2j, 3j});
             expected =
                "(-13+0j)";
            Assert.AreEqual(expected, given.repr);
#endif
            // For 2-D arrays it is the matrix product:

            // >>> a = [[1, 0], [0, 1]]
            // >>> b = [[4, 1], [2, 2]]
            // >>> cp.dot(a, b)
            // array([[4, 1],
            //        [2, 2]])
            // 

#if TODO
             given = a = [[1, 0], [0, 1]];
             given = b = [[4, 1], [2, 2]];
             given = cp.dot(a, b);
             expected =
                "array([[4, 1],\n" +
                "       [2, 2]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.arange(3*4*5*6).reshape((3,4,5,6))
            // >>> b = cp.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
            // >>> cp.dot(a, b)[2,3,2,1,2,2]
            // 499128
            // >>> sum(a[2,3,2,:] * b[1,2,:,2])
            // 499128
            // 

#if TODO
             given = a = cp.arange(3*4*5*6).reshape((3,4,5,6));
             given = b = cp.arange(3*4*5*6){::-1}.reshape((5,4,6,3));
             given = cp.dot(a, b){2,3,2,1,2,2};
             expected =
                "499128";
            Assert.AreEqual(expected, given.repr);
             given = sum(a[2,3,2,:] * b[1,2,:,2]);
             expected =
                "499128";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void multi_dotTest()
        {
            // multi_dot allows you to write:

            // >>> from Cupy.linalg import multi_dot
            // >>> # Prepare some data
            // >>> A = cp.random.random(10000, 100)
            // >>> B = cp.random.random(100, 1000)
            // >>> C = cp.random.random(1000, 5)
            // >>> D = cp.random.random(5, 333)
            // >>> # the actual dot multiplication
            // >>> multi_dot([A, B, C, D])
            // 

#if TODO
            var given = from Cupy.linalg import multi_dot;
             given = # Prepare some data;
             given = A = cp.random.random(10000, 100);
             given = B = cp.random.random(100, 1000);
             given = C = cp.random.random(1000, 5);
             given = D = cp.random.random(5, 333);
             given = # the actual dot multiplication;
             given = multi_dot([A, B, C, D]);
#endif
            // instead of:

            // >>> cp.dot(cp.dot(cp.dot(A, B), C), D)
            // >>> # or
            // >>> A.dot(B).dot(C).dot(D)
            // 

#if TODO
             given = cp.dot(cp.dot(cp.dot(A, B), C), D);
             given = # or;
             given = A.dot(B).dot(C).dot(D);
#endif
        }


        [Test]
        public void vdotTest()
        {
            // >>> a = cp.array([1+2j,3+4j])
            // >>> b = cp.array([5+6j,7+8j])
            // >>> cp.vdot(a, b)
            // (70-8j)
            // >>> cp.vdot(b, a)
            // (70+8j)
            // 

#if TODO
            var given = a = cp.array({1+2j,3+4j});
             given = b = cp.array({5+6j,7+8j});
             given = cp.vdot(a, b);
            var expected =
                "(70-8j)";
            Assert.AreEqual(expected, given.repr);
             given = cp.vdot(b, a);
             expected =
                "(70+8j)";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note that higher-dimensional arrays are flattened!

            // >>> a = cp.array([[1, 4], [5, 6]])
            // >>> b = cp.array([[4, 1], [2, 2]])
            // >>> cp.vdot(a, b)
            // 30
            // >>> cp.vdot(b, a)
            // 30
            // >>> 1*4 + 4*1 + 5*2 + 6*2
            // 30
            // 

#if TODO
             given = a = cp.array({{1, 4}, {5, 6}});
             given = b = cp.array({{4, 1}, {2, 2}});
             given = cp.vdot(a, b);
             expected =
                "30";
            Assert.AreEqual(expected, given.repr);
             given = cp.vdot(b, a);
             expected =
                "30";
            Assert.AreEqual(expected, given.repr);
             given = 1*4 + 4*1 + 5*2 + 6*2;
             expected =
                "30";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void innerTest()
        {
            // Ordinary inner product for vectors:

            // >>> a = cp.array([1,2,3])
            // >>> b = cp.array([0,1,0])
            // >>> cp.inner(a, b)
            // 2
            // 

#if TODO
            var given = a = cp.array({1,2,3});
             given = b = cp.array({0,1,0});
             given = cp.inner(a, b);
            var expected =
                "2";
            Assert.AreEqual(expected, given.repr);
#endif
            // A multidimensional example:

            // >>> a = cp.arange(24).reshape((2,3,4))
            // >>> b = cp.arange(4)
            // >>> cp.inner(a, b)
            // array([[ 14,  38,  62],
            //        [ 86, 110, 134]])
            // 

#if TODO
             given = a = cp.arange(24).reshape((2,3,4));
             given = b = cp.arange(4);
             given = cp.inner(a, b);
             expected =
                "array([[ 14,  38,  62],\n" +
                "       [ 86, 110, 134]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // An example where b is a scalar:

            // >>> cp.inner(cp.eye(2), 7)
            // array([[ 7.,  0.],
            //        [ 0.,  7.]])
            // 

#if TODO
             given = cp.inner(cp.eye(2), 7);
             expected =
                "array([[ 7.,  0.],\n" +
                "       [ 0.,  7.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void outerTest()
        {
            // Make a (very coarse) grid for computing a Mandelbrot set:

            // >>> rl = cp.outer(cp.ones((5,)), cp.linspace(-2, 2, 5))
            // >>> rl
            // array([[-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.]])
            // >>> im = cp.outer(1j*cp.linspace(2, -2, 5), cp.ones((5,)))
            // >>> im
            // array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
            //        [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
            //        [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
            //        [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
            //        [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
            // >>> grid = rl + im
            // >>> grid
            // array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
            //        [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
            //        [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
            //        [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
            //        [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
            // 

#if TODO
            var given = rl = cp.outer(cp.ones((5,)), cp.linspace(-2, 2, 5));
             given = rl;
            var expected =
                "array([[-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.]])";
            Assert.AreEqual(expected, given.repr);
             given = im = cp.outer(1j*cp.linspace(2, -2, 5), cp.ones((5,)));
             given = im;
             expected =
                "array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n" +
                "       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n" +
                "       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n" +
                "       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n" +
                "       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])";
            Assert.AreEqual(expected, given.repr);
             given = grid = rl + im;
             given = grid;
             expected =
                "array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n" +
                "       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n" +
                "       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n" +
                "       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n" +
                "       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // An example using a “vector” of letters:

            // >>> x = cp.array(['a', 'b', 'c'], dtype=object)
            // >>> cp.outer(x, [1, 2, 3])
            // array([[a, aa, aaa],
            //        [b, bb, bbb],
            //        [c, cc, ccc]], dtype=object)
            // 

#if TODO
             given = x = cp.array({'a', 'b', 'c'}, dtype = object);
             given = cp.outer(x, {1, 2, 3});
             expected =
                "array([[a, aa, aaa],\n" +
                "       [b, bb, bbb],\n" +
                "       [c, cc, ccc]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void matmulTest()
        {
            // For 2-D arrays it is the matrix product:

            // >>> a = cp.array([[1, 0],
            // ...               [0, 1]])
            // >>> b = cp.array([[4, 1], 
            // ...               [2, 2]]
            // >>> cp.matmul(a, b)
            // array([[4, 1],
            //        [2, 2]])
            // 

#if TODO
            var given = a = cp.array({{1, 0},;
            var expected =
                "...               [0, 1]])";
            Assert.AreEqual(expected, given.repr);
             given = b = cp.array({{4, 1}, ;
             expected =
                "...               [2, 2]]";
            Assert.AreEqual(expected, given.repr);
             given = cp.matmul(a, b);
             expected =
                "array([[4, 1],\n" +
                "       [2, 2]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // For 2-D mixed with 1-D, the result is the usual.

            // >>> a = cp.array([[1, 0],
            // ...               [0, 1]]
            // >>> b = cp.array([1, 2])
            // >>> cp.matmul(a, b)
            // array([1, 2])
            // >>> cp.matmul(b, a)
            // array([1, 2])
            // 

#if TODO
             given = a = cp.array({{1, 0},;
             expected =
                "...               [0, 1]]";
            Assert.AreEqual(expected, given.repr);
             given = b = cp.array({1, 2});
             given = cp.matmul(a, b);
             expected =
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
             given = cp.matmul(b, a);
             expected =
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Broadcasting is conventional for stacks of arrays

            // >>> a = cp.arange(2 * 2 * 4).reshape((2, 2, 4))
            // >>> b = cp.arange(2 * 2 * 4).reshape((2, 4, 2))
            // >>> cp.matmul(a,b).shape
            // (2, 2, 2)
            // >>> cp.matmul(a, b)[0, 1, 1]
            // 98
            // >>> sum(a[0, 1, :] * b[0 , :, 1])
            // 98
            // 

#if TODO
             given = a = cp.arange(2 * 2 * 4).reshape((2, 2, 4));
             given = b = cp.arange(2 * 2 * 4).reshape((2, 4, 2));
             given = cp.matmul(a,b).shape;
             expected =
                "(2, 2, 2)";
            Assert.AreEqual(expected, given.repr);
             given = cp.matmul(a, b){0, 1, 1};
             expected =
                "98";
            Assert.AreEqual(expected, given.repr);
             given = sum(a[0, 1, :] * b[0 , :, 1]);
             expected =
                "98";
            Assert.AreEqual(expected, given.repr);
#endif
            // Vector, vector returns the scalar inner product, but neither argument
            // is complex-conjugated:

            // >>> cp.matmul([2j, 3j], [2j, 3j])
            // (-13+0j)
            // 

#if TODO
             given = cp.matmul({2j, 3j}, {2j, 3j});
             expected =
                "(-13+0j)";
            Assert.AreEqual(expected, given.repr);
#endif
            // Scalar multiplication raises an error.

            // >>> cp.matmul([1,2], 3)
            // Traceback (most recent call last):
            // ...
            // ValueError: matmul: Input operand 1 does not have enough dimensions ...
            // 

#if TODO
             given = cp.matmul({1,2}, 3);
             expected =
                "Traceback (most recent call last):\n" +
                "...\n" +
                "ValueError: matmul: Input operand 1 does not have enough dimensions ...";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void tensordotTest()
        {
            // A “traditional” example:

            // >>> a = cp.arange(60.).reshape(3,4,5)
            // >>> b = cp.arange(24.).reshape(4,3,2)
            // >>> c = cp.tensordot(a,b, axes=([1,0],[0,1]))
            // >>> c.shape
            // (5, 2)
            // >>> c
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> # A slower but equivalent way of computing the same...
            // >>> d = cp.zeros((5,2))
            // >>> for i in range(5):
            // ...   for j in range(2):
            // ...     for k in range(3):
            // ...       for n in range(4):
            // ...         d[i,j] += a[k,n,i] * b[n,k,j]
            // >>> c == d
            // array([[ True,  True],
            //        [ True,  True],
            //        [ True,  True],
            //        [ True,  True],
            //        [ True,  True]])
            // 

#if TODO
            var given = a = cp.arange(60.).reshape(3,4,5);
             given = b = cp.arange(24.).reshape(4,3,2);
             given = c = cp.tensordot(a,b, axes = ({1,0},{0,1}));
             given = c.shape;
            var expected =
                "(5, 2)";
            Assert.AreEqual(expected, given.repr);
             given = c;
             expected =
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
             given = # A slower but equivalent way of computing the same...;
             given = d = cp.zeros((5,2));
             given = for i in range(5):;
             expected =
                "...   for j in range(2):\n" +
                "...     for k in range(3):\n" +
                "...       for n in range(4):\n" +
                "...         d[i,j] += a[k,n,i] * b[n,k,j]";
            Assert.AreEqual(expected, given.repr);
             given = c == d;
             expected =
                "array([[ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // An extended example taking advantage of the overloading of + and *:

            // >>> a = cp.array(range(1, 9))
            // >>> a.shape = (2, 2, 2)
            // >>> A = cp.array(('a', 'b', 'c', 'd'), dtype=object)
            // >>> A.shape = (2, 2)
            // >>> a; A
            // array([[[1, 2],
            //         [3, 4]],
            //        [[5, 6],
            //         [7, 8]]])
            // array([[a, b],
            //        [c, d]], dtype=object)
            // 

#if TODO
             given = a = cp.array(range(1, 9));
             given = a.shape = (2, 2, 2);
             given = A = cp.array(('a', 'b', 'c', 'd'), dtype = object);
             given = A.shape = (2, 2);
             given = a; A;
             expected =
                "array([[[1, 2],\n" +
                "        [3, 4]],\n" +
                "       [[5, 6],\n" +
                "        [7, 8]]])\n" +
                "array([[a, b],\n" +
                "       [c, d]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A) # third argument default is 2 for double-contraction
            // array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A) # third argument default is 2 for double-contraction;
             expected =
                "array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, 1)
            // array([[[acc, bdd],
            //         [aaacccc, bbbdddd]],
            //        [[aaaaacccccc, bbbbbdddddd],
            //         [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A, 1);
             expected =
                "array([[[acc, bdd],\n" +
                "        [aaacccc, bbbdddd]],\n" +
                "       [[aaaaacccccc, bbbbbdddddd],\n" +
                "        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, 0) # tensor product (result too long to incl.)
            // array([[[[[a, b],
            //           [c, d]],
            //           ...
            // 

#if TODO
             given = cp.tensordot(a, A, 0) # tensor product (result too long to incl.);
             expected =
                "array([[[[[a, b],\n" +
                "          [c, d]],\n" +
                "          ...";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, (0, 1))
            // array([[[abbbbb, cddddd],
            //         [aabbbbbb, ccdddddd]],
            //        [[aaabbbbbbb, cccddddddd],
            //         [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A, (0, 1));
             expected =
                "array([[[abbbbb, cddddd],\n" +
                "        [aabbbbbb, ccdddddd]],\n" +
                "       [[aaabbbbbbb, cccddddddd],\n" +
                "        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, (2, 1))
            // array([[[abb, cdd],
            //         [aaabbbb, cccdddd]],
            //        [[aaaaabbbbbb, cccccdddddd],
            //         [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A, (2, 1));
             expected =
                "array([[[abb, cdd],\n" +
                "        [aaabbbb, cccdddd]],\n" +
                "       [[aaaaabbbbbb, cccccdddddd],\n" +
                "        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, ((0, 1), (0, 1)))
            // array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A, ((0, 1), (0, 1)));
             expected =
                "array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.tensordot(a, A, ((2, 1), (1, 0)))
            // array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)
            // 

#if TODO
             given = cp.tensordot(a, A, ((2, 1), (1, 0)));
             expected =
                "array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void einsumTest()
        {
            // >>> a = cp.arange(25).reshape(5,5)
            // >>> b = cp.arange(5)
            // >>> c = cp.arange(6).reshape(2,3)
            // 

            var a = cp.arange(25).reshape(5, 5);
            var b = cp.arange(5);
            var c = cp.arange(6).reshape(2, 3);
            // Trace of a matrix:

            // >>> cp.einsum('ii', a)
            // 60
            // >>> cp.einsum(a, [0,0])
            // 60
            // >>> cp.trace(a)
            // 60
            // 

            var given = cp.einsum("ii", a);
            var expected =
                "60";
#if TODO
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum(new[] { a, (NDarray)cp.array(0, 0) });
            expected =
               "60";
            Assert.AreEqual(expected, given.repr);
#endif
            given = a.trace();
            expected =
                "60";
            Assert.AreEqual(expected, given.repr);

            // Extract the diagonal (requires explicit form):

            // >>> cp.einsum('ii->i', a)
            // array([ 0,  6, 12, 18, 24])
            // >>> cp.einsum(a, [0,0], [0])
            // array([ 0,  6, 12, 18, 24])
            // >>> cp.diag(a)
            // array([ 0,  6, 12, 18, 24])
            // 

            given = cp.einsum("ii->i", a);
            expected =
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
#if TODO
            given = cp.einsum(a, {0,0}, {0});
             expected =
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
#endif
            given = cp.diag(a);
            expected =
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
            // Sum over an axis (requires explicit form):

            // >>> cp.einsum('ij->i', a)
            // array([ 10,  35,  60,  85, 110])
            // >>> cp.einsum(a, [0,1], [0])
            // array([ 10,  35,  60,  85, 110])
            // >>> cp.sum(a, axis=1)
            // array([ 10,  35,  60,  85, 110])
            // 

            given = cp.einsum("ij->i", a);
            expected =
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(a, {0,1}, {0});
             expected =
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
#endif

            given = a.sum(1);
            expected =
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
            // For higher dimensional arrays summing a single axis can be done with ellipsis:

            // >>> cp.einsum('...j->...', a)
            // array([ 10,  35,  60,  85, 110])
            // >>> cp.einsum(a, [Ellipsis,1], [Ellipsis])
            // array([ 10,  35,  60,  85, 110])
            // 

            given = cp.einsum("...j->...", a);
            expected =
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(a, {Ellipsis,1}, {Ellipsis});
             expected =
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Compute a matrix transpose, or reorder any number of axes:

            // >>> cp.einsum('ji', c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> cp.einsum('ij->ji', c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> cp.einsum(c, [1,0])
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> cp.transpose(c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // 

            given = cp.einsum("ji", c);
            expected =
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum("ij->ji", c);
            expected =
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
#if TODO
            given = cp.einsum(c, {1,0});
             expected =
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
#endif
            given = cp.transpose(c);
            expected =
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);

            // Vector inner products:

            // >>> cp.einsum('i,i', b, b)
            // 30
            // >>> cp.einsum(b, [0], b, [0])
            // 30
            // >>> cp.inner(b,b)
            // 30
            // 

            given = cp.einsum("i,i", b, b);
            expected =
                "30";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(b, {0}, b, {0});
             expected =
                "30";
            Assert.AreEqual(expected, given.repr);
#endif
            given = b.inner(b);
            expected =
                "30";
            Assert.AreEqual(expected, given.repr);

            // Matrix vector multiplication:

            // >>> cp.einsum('ij,j', a, b)
            // array([ 30,  80, 130, 180, 230])
            // >>> cp.einsum(a, [0,1], b, [1])
            // array([ 30,  80, 130, 180, 230])
            // >>> cp.dot(a, b)
            // array([ 30,  80, 130, 180, 230])
            // >>> cp.einsum('...j,j', a, b)
            // array([ 30,  80, 130, 180, 230])
            // 

            given = cp.einsum("ij,j", a, b);
            expected =
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(a, {0,1}, b, {1});
             expected =
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
#endif
            given = a.dot(b);
            expected =
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum("...j,j", a, b);
            expected =
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);

            // Broadcasting and scalar multiplication:

            // >>> cp.einsum('..., ...', 3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> cp.einsum(',ij', 3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> cp.einsum(3, [Ellipsis], c, [Ellipsis])
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> cp.multiply(3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // 

            given = cp.einsum("..., ...", cp.asarray(3), c);
            expected =
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum(",ij", cp.asarray(3), c);
            expected =
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(3, {Ellipsis}, c, {Ellipsis});
             expected =
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
#endif
            given = cp.asarray(3).multiply(c);
            expected =
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
            // Vector outer product:

            // >>> cp.einsum('i,j', cp.arange(2)+1, b)
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // >>> cp.einsum(cp.arange(2)+1, [0], b, [1])
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // >>> cp.outer(cp.arange(2)+1, b)
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // 


            given = cp.einsum("i,j", cp.arange(2) + 1, b);
            expected =
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
#if TODO
            given = cp.einsum(cp.arange(2)+1, {0}, b, {1});
             expected =
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
#endif
            given = (cp.arange(2) + 1).outer(b);
            expected =
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
            // Tensor contraction:

            // >>> a = cp.arange(60.).reshape(3,4,5)
            // >>> b = cp.arange(24.).reshape(4,3,2)
            // >>> cp.einsum('ijk,jil->kl', a, b)
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> cp.einsum(a, [0,1,2], b, [1,0,3], [2,3])
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> cp.tensordot(a,b, axes=([1,0],[0,1]))
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // 

            given = a = cp.arange(60.0).reshape(3, 4, 5);
            given = b = cp.arange(24.0).reshape(4, 3, 2);
            given = cp.einsum("ijk,jil->kl", a, b);
            expected =
                "array([[4400., 4730.],\n" +
                "       [4532., 4874.],\n" +
                "       [4664., 5018.],\n" +
                "       [4796., 5162.],\n" +
                "       [4928., 5306.]], dtype=float64)";
            Assert.AreEqual(expected, given.repr);
#if TODO
             given = cp.einsum(a, {0,1,2}, b, {1,0,3}, {2,3});
             expected =
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);

            given = cp.tensordot(a,b, axes:new int[,]{{1,0},{0,1}});
             expected =
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
#endif

            // Writeable returned arrays (since version 1.10.0):

            // >>> a = cp.zeros((3, 3))
            // >>> cp.einsum('ii->i', a)[:] = 1
            // >>> a
            // array([[ 1.,  0.,  0.],
            //        [ 0.,  1.,  0.],
            //        [ 0.,  0.,  1.]])
            // 


            a = cp.zeros((3, 3));
            cp.einsum("ii->i", a)[":"] = cp.asarray(1);
            given = a;
            expected =
                "array([[1., 0., 0.],\n" +
                "       [0., 1., 0.],\n" +
                "       [0., 0., 1.]], dtype=float64)";
            Assert.AreEqual(expected, given.repr);

            // Example of ellipsis use:

            // >>> a = cp.arange(6).reshape((3,2))
            // >>> b = cp.arange(12).reshape((4,3))
            // >>> cp.einsum('ki,jk->ij', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // >>> cp.einsum('ki,...k->i...', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // >>> cp.einsum('k...,jk', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // 

            given = a = cp.arange(6).reshape((3, 2));
            given = b = cp.arange(12).reshape((4, 3));
            given = cp.einsum("ki,jk->ij", a, b);
            expected =
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum("ki,...k->i...", a, b);
            expected =
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);
            given = cp.einsum("k...,jk", a, b);
            expected =
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);

            // Chained array operations. For more complicated contractions, speed ups
            // might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the
            // ‘optimal’ path and repeatedly applying it, using an
            // einsum_path insertion (since version 1.12.0). Performance improvements can be
            // particularly significant with larger arrays:

            // >>> a = cp.ones(64).reshape(2,4,8)
            // # Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)
            // >>> for iteration in range(500):
            // ...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)
            // # Sub-optimal `einsum` (due to repeated path calculation time): ~330ms
            // >>> for iteration in range(500):
            // ...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')
            // # Greedy `einsum` (faster optimal path approximation): ~160ms
            // >>> for iteration in range(500):
            // ...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')
            // # Optimal `einsum` (best usage pattern in some use cases): ~110ms
            // >>> path = cp.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]
            // >>> for iteration in range(500):
            // ...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)
            // 

#if TODO
             given = a = cp.ones(64).reshape(2,4,8);
            // Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)
             given = for iteration in range(500):;
             expected =
                "...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)";
            Assert.AreEqual(expected, given.repr);
            // Sub-optimal `einsum` (due to repeated path calculation time): ~330ms
             given = for iteration in range(500):;
             expected =
                "...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')";
            Assert.AreEqual(expected, given.repr);
            // Greedy `einsum` (faster optimal path approximation): ~160ms
             given = for iteration in range(500):;
             expected =
                "...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')";
            Assert.AreEqual(expected, given.repr);
            // Optimal `einsum` (best usage pattern in some use cases): ~110ms
             given = path = cp.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize = 'optimal'){0};
             given = for iteration in range(500):;
             expected =
                "...     cp.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void einsum_pathTest()
        {
            // We can begin with a chain dot example. In this case, it is optimal to
            // contract the b and c tensors first as represented by the first
            // element of the path (1, 2). The resulting tensor is added to the end
            // of the contraction and the remaining contraction (0, 1) is then
            // completed.

            // >>> a = cp.random.rand(2, 2)
            // >>> b = cp.random.rand(2, 5)
            // >>> c = cp.random.rand(5, 2)
            // >>> path_info = cp.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
            // >>> print(path_info[0])
            // ['einsum_path', (1, 2), (0, 1)]
            // >>> print(path_info[1])
            //   Complete contraction:  ij,jk,kl->il
            //          Naive scaling:  4
            //      Optimized scaling:  3
            //       Naive FLOP count:  1.600e+02
            //   Optimized FLOP count:  5.600e+01
            //    Theoretical speedup:  2.857
            //   Largest intermediate:  4.000e+00 elements
            // -------------------------------------------------------------------------
            // scaling                  current                                remaining
            // -------------------------------------------------------------------------
            //    3                   kl,jk->jl                                ij,jl->il
            //    3                   jl,ij->il                                   il->il
            // 

#if TODO
            var given = a = cp.random.rand(2, 2);
             given = b = cp.random.rand(2, 5);
             given = c = cp.random.rand(5, 2);
             given = path_info = cp.einsum_path('ij,jk,kl->il', a, b, c, optimize = 'greedy');
             given = print(path_info[0]);
            var expected =
                "['einsum_path', (1, 2), (0, 1)]";
            Assert.AreEqual(expected, given.repr);
             given = print(path_info[1]);
             expected =
                "  Complete contraction:  ij,jk,kl->il\n" +
                "         Naive scaling:  4\n" +
                "     Optimized scaling:  3\n" +
                "      Naive FLOP count:  1.600e+02\n" +
                "  Optimized FLOP count:  5.600e+01\n" +
                "   Theoretical speedup:  2.857\n" +
                "  Largest intermediate:  4.000e+00 elements\n" +
                "-------------------------------------------------------------------------\n" +
                "scaling                  current                                remaining\n" +
                "-------------------------------------------------------------------------\n" +
                "   3                   kl,jk->jl                                ij,jl->il\n" +
                "   3                   jl,ij->il                                   il->il";
            Assert.AreEqual(expected, given.repr);
#endif
            // A more complex index transformation example.

            // >>> I = cp.random.rand(10, 10, 10, 10)
            // >>> C = cp.random.rand(10, 10)
            // >>> path_info = cp.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
            //                                optimize='greedy')
            // 

#if TODO
             given = I = cp.random.rand(10, 10, 10, 10);
             given = C = cp.random.rand(10, 10);
             given = path_info = cp.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,;
             expected =
                "                               optimize='greedy')";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> print(path_info[0])
            // ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
            // >>> print(path_info[1])
            //   Complete contraction:  ea,fb,abcd,gc,hd->efgh
            //          Naive scaling:  8
            //      Optimized scaling:  5
            //       Naive FLOP count:  8.000e+08
            //   Optimized FLOP count:  8.000e+05
            //    Theoretical speedup:  1000.000
            //   Largest intermediate:  1.000e+04 elements
            // --------------------------------------------------------------------------
            // scaling                  current                                remaining
            // --------------------------------------------------------------------------
            //    5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
            //    5               bcde,fb->cdef                         gc,hd,cdef->efgh
            //    5               cdef,gc->defg                            hd,defg->efgh
            //    5               defg,hd->efgh                               efgh->efgh
            // 

#if TODO
             given = print(path_info[0]);
             expected =
                "['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]";
            Assert.AreEqual(expected, given.repr);
             given = print(path_info[1]);
             expected =
                "  Complete contraction:  ea,fb,abcd,gc,hd->efgh\n" +
                "         Naive scaling:  8\n" +
                "     Optimized scaling:  5\n" +
                "      Naive FLOP count:  8.000e+08\n" +
                "  Optimized FLOP count:  8.000e+05\n" +
                "   Theoretical speedup:  1000.000\n" +
                "  Largest intermediate:  1.000e+04 elements\n" +
                "--------------------------------------------------------------------------\n" +
                "scaling                  current                                remaining\n" +
                "--------------------------------------------------------------------------\n" +
                "   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh\n" +
                "   5               bcde,fb->cdef                         gc,hd,cdef->efgh\n" +
                "   5               cdef,gc->defg                            hd,defg->efgh\n" +
                "   5               defg,hd->efgh                               efgh->efgh";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void matrix_powerTest()
        {
            // >>> from Cupy.linalg import matrix_power
            // >>> i = cp.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
            // >>> matrix_power(i, 3) # should = -i
            // array([[ 0, -1],
            //        [ 1,  0]])
            // >>> matrix_power(i, 0)
            // array([[1, 0],
            //        [0, 1]])
            // >>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
            // array([[ 0.,  1.],
            //        [-1.,  0.]])
            // 

#if TODO
            var given = from Cupy.linalg import matrix_power;
             given = i = cp.array({{0, 1}, {-1, 0}}) # matrix equiv. of the imaginary unit;
             given = matrix_power(i, 3) # should = -i;
            var expected =
                "array([[ 0, -1],\n" +
                "       [ 1,  0]])";
            Assert.AreEqual(expected, given.repr);
             given = matrix_power(i, 0);
             expected =
                "array([[1, 0],\n" +
                "       [0, 1]])";
            Assert.AreEqual(expected, given.repr);
             given = matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements;
             expected =
                "array([[ 0.,  1.],\n" +
                "       [-1.,  0.]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Somewhat more sophisticated example

            // >>> q = cp.zeros((4, 4))
            // >>> q[0:2, 0:2] = -i
            // >>> q[2:4, 2:4] = i
            // >>> q # one of the three quaternion units not equal to 1
            // array([[ 0., -1.,  0.,  0.],
            //        [ 1.,  0.,  0.,  0.],
            //        [ 0.,  0.,  0.,  1.],
            //        [ 0.,  0., -1.,  0.]])
            // >>> matrix_power(q, 2) # = -cp.eye(4)
            // array([[-1.,  0.,  0.,  0.],
            //        [ 0., -1.,  0.,  0.],
            //        [ 0.,  0., -1.,  0.],
            //        [ 0.,  0.,  0., -1.]])
            // 

#if TODO
             given = q = cp.zeros((4, 4));
             given = q[0:2, 0:2] = -i;
             given = q[2:4, 2:4] = i;
             given = q # one of the three quaternion units not equal to 1;
             expected =
                "array([[ 0., -1.,  0.,  0.],\n" +
                "       [ 1.,  0.,  0.,  0.],\n" +
                "       [ 0.,  0.,  0.,  1.],\n" +
                "       [ 0.,  0., -1.,  0.]])";
            Assert.AreEqual(expected, given.repr);
             given = matrix_power(q, 2) # = -cp.eye(4);
             expected =
                "array([[-1.,  0.,  0.,  0.],\n" +
                "       [ 0., -1.,  0.,  0.],\n" +
                "       [ 0.,  0., -1.,  0.],\n" +
                "       [ 0.,  0.,  0., -1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void kronTest()
        {
            // >>> cp.kron([1,10,100], [5,6,7])
            // array([  5,   6,   7,  50,  60,  70, 500, 600, 700])
            // >>> cp.kron([5,6,7], [1,10,100])
            // array([  5,  50, 500,   6,  60, 600,   7,  70, 700])
            // 

#if TODO
            var given = cp.kron({1,10,100}, {5,6,7});
            var expected =
                "array([  5,   6,   7,  50,  60,  70, 500, 600, 700])";
            Assert.AreEqual(expected, given.repr);
             given = cp.kron({5,6,7}, {1,10,100});
             expected =
                "array([  5,  50, 500,   6,  60, 600,   7,  70, 700])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.kron(cp.eye(2), cp.ones((2,2)))
            // array([[ 1.,  1.,  0.,  0.],
            //        [ 1.,  1.,  0.,  0.],
            //        [ 0.,  0.,  1.,  1.],
            //        [ 0.,  0.,  1.,  1.]])
            // 

#if TODO
             given = cp.kron(cp.eye(2), cp.ones((2,2)));
             expected =
                "array([[ 1.,  1.,  0.,  0.],\n" +
                "       [ 1.,  1.,  0.,  0.],\n" +
                "       [ 0.,  0.,  1.,  1.],\n" +
                "       [ 0.,  0.,  1.,  1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.arange(100).reshape((2,5,2,5))
            // >>> b = cp.arange(24).reshape((2,3,4))
            // >>> c = cp.kron(a,b)
            // >>> c.shape
            // (2, 10, 6, 20)
            // >>> I = (1,3,0,2)
            // >>> J = (0,2,1)
            // >>> J1 = (0,) + J             # extend to ndim=4
            // >>> S1 = (1,) + b.shape
            // >>> K = tuple(cp.array(I) * cp.array(S1) + cp.array(J1))
            // >>> c[K] == a[I]*b[J]
            // True
            // 

#if TODO
             given = a = cp.arange(100).reshape((2,5,2,5));
             given = b = cp.arange(24).reshape((2,3,4));
             given = c = cp.kron(a,b);
             given = c.shape;
             expected =
                "(2, 10, 6, 20)";
            Assert.AreEqual(expected, given.repr);
             given = I = (1,3,0,2);
             given = J = (0,2,1);
             given = J1 = (0,) + J             # extend to ndim = 4;
             given = S1 = (1,) + b.shape;
             given = K = tuple(cp.array(I) * cp.array(S1) + cp.array(J1));
             given = c[K] == a[I]*b[J];
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void qrTest()
        {
            // >>> a = cp.random.randn(9, 6)
            // >>> q, r = cp.linalg.qr(a)
            // >>> cp.allclose(a, cp.dot(q, r))  # a does equal qr
            // True
            // >>> r2 = cp.linalg.qr(a, mode='r')
            // >>> r3 = cp.linalg.qr(a, mode='economic')
            // >>> cp.allclose(r, r2)  # mode='r' returns the same r as mode='full'
            // True
            // >>> # But only triu parts are guaranteed equal when mode='economic'
            // >>> cp.allclose(r, cp.triu(r3[:6,:6], k=0))
            // True
            // 

            {
                var a = cp.random.randn(9, 6);
                var (q, r, _) = cp.linalg.qr(a);
                //Console.WriteLine("r: " + r.repr);
                var given = a.allclose(q.dot(r)); // a does equal qr;
                Assert.AreEqual(true, given);
                var (r2, _, _) = cp.linalg.qr(a, "r");
                //Console.WriteLine("r2: " + r2.repr);
                //var (r3, _, _) = cp.linalg.qr(a, "economic");
                given = r.allclose(r2); // mode='r' returns the same r as mode='full';
                Assert.AreEqual(true, given);
            }
#if TODO
            // But only triu parts are guaranteed equal when mode='economic';
            given = cp.allclose(r, cp.triu(r3{:6,:6}, k = 0));
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif

            // Example illustrating a common use of qr: solving of least squares
            // problems

            // What are the least-squares-best m and y0 in y = y0 + mx for
            // the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
            // and you’ll see that it should be y0 = 0, m = 1.)  The answer is provided
            // by solving the over-determined matrix equation Ax = b, where:

            // A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
            // x = array([[y0], [m]])
            // b = array([[1], [0], [2], [1]])
            // 

            // If A = qr such that q is orthonormal (which is always possible via
            // Gram-Schmidt), then x = inv(r) * (q.T) * b.  (In Cupy practice,
            // however, we simply use lstsq.)

            //A = cp.array([[0, 1], [1, 1], [1, 1], [2, 1]])
            //A
            //array([[0, 1],
            //       [1, 1],
            //       [1, 1],
            //       [2, 1]])
            //b = cp.array([1, 2, 2, 3])
            //q, r = cp.linalg.qr(A)
            //p = cp.dot(q.T, b)
            //cp.dot(cp.linalg.inv(r), p)
            //array([  1.,   1.]) 
            // 
            {
                var A = cp.array(new[,] { { 0, 1 }, { 1, 1 }, { 1, 1 }, { 2, 1 } });
                NDarray given = A;
                var expected =
                    "array([[0, 1],\n" +
                    "       [1, 1],\n" +
                    "       [1, 1],\n" +
                    "       [2, 1]])";
                Assert.AreEqual(expected, given.repr);
                var b = cp.array(1, 2, 2, 3);
                var (q, r, _) = cp.linalg.qr(A);
                var p = q.T.dot(b);
                //Console.WriteLine("p:" + p.repr);
                var r_inv = cp.linalg.inv(r);
                given = r_inv.dot(p);
                expected = "array([1., 1.], dtype=float64)";
                Assert.AreEqual(expected, given.repr);
            }
        }


        [Test]
        public void condTest()
        {
            // >>> from Cupy import linalg as LA
            // >>> a = cp.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
            // >>> a
            // array([[ 1,  0, -1],
            //        [ 0,  1,  0],
            //        [ 1,  0,  1]])
            // >>> LA.cond(a)
            // 1.4142135623730951
            // >>> LA.cond(a, 'fro')
            // 3.1622776601683795
            // >>> LA.cond(a, cp.inf)
            // 2.0
            // >>> LA.cond(a, -cp.inf)
            // 1.0
            // >>> LA.cond(a, 1)
            // 2.0
            // >>> LA.cond(a, -1)
            // 1.0
            // >>> LA.cond(a, 2)
            // 1.4142135623730951
            // >>> LA.cond(a, -2)
            // 0.70710678118654746
            // >>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))
            // 0.70710678118654746
            // 

#if TODO
            var given = from Cupy import linalg as LA;
             given = a = cp.array({{1, 0, -1}, {0, 1, 0}, {1, 0, 1}});
             given = a;
            var expected =
                "array([[ 1,  0, -1],\n" +
                "       [ 0,  1,  0],\n" +
                "       [ 1,  0,  1]])";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a);
             expected =
                "1.4142135623730951";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, 'fro');
             expected =
                "3.1622776601683795";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, cp.inf);
             expected =
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, -cp.inf);
             expected =
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, 1);
             expected =
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, -1);
             expected =
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, 2);
             expected =
                "1.4142135623730951";
            Assert.AreEqual(expected, given.repr);
             given = LA.cond(a, -2);
             expected =
                "0.70710678118654746";
            Assert.AreEqual(expected, given.repr);
             given = min(LA.svd(a, compute_uv = 0))*min(LA.svd(LA.inv(a), compute_uv = 0));
             expected =
                "0.70710678118654746";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void matrix_rankTest()
        {
            // >>> from Cupy.linalg import matrix_rank
            // >>> matrix_rank(cp.eye(4)) # Full rank matrix
            // 4
            // >>> I=cp.eye(4); I[-1,-1] = 0. # rank deficient matrix
            // >>> matrix_rank(I)
            // 3
            // >>> matrix_rank(cp.ones((4,))) # 1 dimension - rank 1 unless all 0
            // 1
            // >>> matrix_rank(cp.zeros((4,)))
            // 0
            // 

#if TODO
            var given = from Cupy.linalg import matrix_rank;
             given = matrix_rank(cp.eye(4)) # Full rank matrix;
            var expected =
                "4";
            Assert.AreEqual(expected, given.repr);
             given = I = cp.eye(4); I{-1,-1} = 0. # rank deficient matrix;
             given = matrix_rank(I);
             expected =
                "3";
            Assert.AreEqual(expected, given.repr);
             given = matrix_rank(cp.ones((4,))) # 1 dimension - rank 1 unless all 0;
             expected =
                "1";
            Assert.AreEqual(expected, given.repr);
             given = matrix_rank(cp.zeros((4,)));
             expected =
                "0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void slogdetTest()
        {
            // The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> (sign, logdet) = cp.linalg.slogdet(a)
            // >>> (sign, logdet)
            // (-1, 0.69314718055994529)
            // >>> sign * cp.exp(logdet)
            // -2.0
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, 4}});
             given = (sign, logdet) = cp.linalg.slogdet(a);
             given = (sign, logdet);
            var expected =
                "(-1, 0.69314718055994529)";
            Assert.AreEqual(expected, given.repr);
             given = sign * cp.exp(logdet);
             expected =
                "-2.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // Computing log-determinants for a stack of matrices:

            // >>> a = cp.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
            // >>> a.shape
            // (3, 2, 2)
            // >>> sign, logdet = cp.linalg.slogdet(a)
            // >>> (sign, logdet)
            // (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
            // >>> sign * cp.exp(logdet)
            // array([-2., -3., -8.])
            // 

#if TODO
             given = a = cp.array({ {{1, 2}, {3, 4}}, {{1, 2}, {2, 1}}, {{1, 3}, {3, 1}} });
             given = a.shape;
             expected =
                "(3, 2, 2)";
            Assert.AreEqual(expected, given.repr);
             given = sign, logdet = cp.linalg.slogdet(a);
             given = (sign, logdet);
             expected =
                "(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))";
            Assert.AreEqual(expected, given.repr);
             given = sign * cp.exp(logdet);
             expected =
                "array([-2., -3., -8.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // This routine succeeds where ordinary det does not:

            // >>> cp.linalg.det(cp.eye(500) * 0.1)
            // 0.0
            // >>> cp.linalg.slogdet(cp.eye(500) * 0.1)
            // (1, -1151.2925464970228)
            // 

#if TODO
             given = cp.linalg.det(cp.eye(500) * 0.1);
             expected =
                "0.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.linalg.slogdet(cp.eye(500) * 0.1);
             expected =
                "(1, -1151.2925464970228)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void traceTest()
        {
            // >>> cp.trace(cp.eye(3))
            // 3.0
            // >>> a = cp.arange(8).reshape((2,2,2))
            // >>> cp.trace(a)
            // array([6, 8])
            // 

#if TODO
            var given = cp.trace(cp.eye(3));
            var expected =
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given = a = cp.arange(8).reshape((2,2,2));
             given = cp.trace(a);
             expected =
                "array([6, 8])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.arange(24).reshape((2,2,2,3))
            // >>> cp.trace(a).shape
            // (2, 3)
            // 

#if TODO
             given = a = cp.arange(24).reshape((2,2,2,3));
             given = cp.trace(a).shape;
             expected =
                "(2, 3)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void tensorsolveTest()
        {
            // >>> a = cp.eye(2*3*4)
            // >>> a.shape = (2*3, 4, 2, 3, 4)
            // >>> b = cp.random.randn(2*3, 4)
            // >>> x = cp.linalg.tensorsolve(a, b)
            // >>> x.shape
            // (2, 3, 4)
            // >>> cp.allclose(cp.tensordot(a, x, axes=3), b)
            // True
            // 

#if TODO
            var given = a = cp.eye(2*3*4);
             given = a.shape = (2*3, 4, 2, 3, 4);
             given = b = cp.random.randn(2*3, 4);
             given = x = cp.linalg.tensorsolve(a, b);
             given = x.shape;
            var expected =
                "(2, 3, 4)";
            Assert.AreEqual(expected, given.repr);
             given = cp.allclose(cp.tensordot(a, x, axes = 3), b);
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void tensorinvTest()
        {
            // >>> a = cp.eye(4*6)
            // >>> a.shape = (4, 6, 8, 3)
            // >>> ainv = cp.linalg.tensorinv(a, ind=2)
            // >>> ainv.shape
            // (8, 3, 4, 6)
            // >>> b = cp.random.randn(4, 6)
            // >>> cp.allclose(cp.tensordot(ainv, b), cp.linalg.tensorsolve(a, b))
            // True
            // 

#if TODO
            var given = a = cp.eye(4*6);
             given = a.shape = (4, 6, 8, 3);
             given = ainv = cp.linalg.tensorinv(a, ind = 2);
             given = ainv.shape;
            var expected =
                "(8, 3, 4, 6)";
            Assert.AreEqual(expected, given.repr);
             given = b = cp.random.randn(4, 6);
             given = cp.allclose(cp.tensordot(ainv, b), cp.linalg.tensorsolve(a, b));
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.eye(4*6)
            // >>> a.shape = (24, 8, 3)
            // >>> ainv = cp.linalg.tensorinv(a, ind=1)
            // >>> ainv.shape
            // (8, 3, 24)
            // >>> b = cp.random.randn(24)
            // >>> cp.allclose(cp.tensordot(ainv, b, 1), cp.linalg.tensorsolve(a, b))
            // True
            // 

#if TODO
             given = a = cp.eye(4*6);
             given = a.shape = (24, 8, 3);
             given = ainv = cp.linalg.tensorinv(a, ind = 1);
             given = ainv.shape;
             expected =
                "(8, 3, 24)";
            Assert.AreEqual(expected, given.repr);
             given = b = cp.random.randn(24);
             given = cp.allclose(cp.tensordot(ainv, b, 1), cp.linalg.tensorsolve(a, b));
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void LinAlgErrorTest()
        {
            // >>> from Cupy import linalg as LA
            // >>> LA.inv(cp.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            //   File "...linalg.py", line 350,
            //     in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
            //   File "...linalg.py", line 249,
            //     in solve
            //     raise LinAlgError('Singular matrix')
            // Cupy.linalg.LinAlgError: Singular matrix
            // 

#if TODO
            var given = from Cupy import linalg as LA;
             given = LA.inv(cp.zeros((2,2)));
            var expected =
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "  File "...linalg.py", line 350,\n" +
                "    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n" +
                "  File "...linalg.py", line 249,\n" +
                "    in solve\n" +
                "    raise LinAlgError('Singular matrix')\n" +
                "Cupy.linalg.LinAlgError: Singular matrix";
            Assert.AreEqual(expected, given.repr);
#endif
        }
    }
}