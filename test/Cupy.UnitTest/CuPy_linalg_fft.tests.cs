// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using Cupy.Models;
using NUnit.Framework;
using LA = Cupy.cp.linalg;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class Cupy_linalg_fftTest : BaseTestCase
    {
        [Test]
        public void choleskyTest()
        {
            // >>> A = cp.array([[1,-2j],[2j,5]])
            // >>> A
            // array([[ 1.+0.j,  0.-2.j],
            //        [ 0.+2.j,  5.+0.j]])
            // >>> L = cp.linalg.cholesky(A)
            // >>> L
            // array([[ 1.+0.j,  0.+0.j],
            //        [ 0.+2.j,  1.+0.j]])
            // >>> cp.dot(L, L.T.conj()) # verify that L * L.H = A
            // array([[ 1.+0.j,  0.-2.j],
            //        [ 0.+2.j,  5.+0.j]])
            // >>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
            // >>> cp.linalg.cholesky(A) # an ndarray object is returned
            // array([[ 1.+0.j,  0.+0.j],
            //        [ 0.+2.j,  1.+0.j]])
            // >>> # But a matrix object is returned if A is a matrix object
            // >>> LA.cholesky(cp.matrix(A))
            // matrix([[ 1.+0.j,  0.+0.j],
            //         [ 0.+2.j,  1.+0.j]])
            // 

#if TODO
            var given = A = cp.array({{1,-2j},{2j,5}});
             given = A;
            var expected =
                "array([[ 1.+0.j,  0.-2.j],\n" +
                "       [ 0.+2.j,  5.+0.j]])";
            Assert.That(expected, given.repr);
             given = L = cp.linalg.cholesky(A);
             given = L;
             expected =
                "array([[ 1.+0.j,  0.+0.j],\n" +
                "       [ 0.+2.j,  1.+0.j]])";
            Assert.That(expected, given.repr);
             given = cp.dot(L, L.T.conj()) # verify that L * L.H = A;
             expected =
                "array([[ 1.+0.j,  0.-2.j],\n" +
                "       [ 0.+2.j,  5.+0.j]])";
            Assert.That(expected, given.repr);
             given = A = [[1,-2j],[2j,5]] # what happens if A is only array_like?;
             given = cp.linalg.cholesky(A) # an ndarray object is returned;
             expected =
                "array([[ 1.+0.j,  0.+0.j],\n" +
                "       [ 0.+2.j,  1.+0.j]])";
            Assert.That(expected, given.repr);
             given = # But a matrix object is returned if A is a matrix object;
             given = LA.cholesky(cp.matrix(A));
             expected =
                "matrix([[ 1.+0.j,  0.+0.j],\n" +
                "        [ 0.+2.j,  1.+0.j]])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void detTest()
        {
            // The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> cp.linalg.det(a)
            // -2.0
            // 

            var a = cp.array(new[,] { { 1, 2 }, { 3, 4 } });
            var given = LA.det(a);
            var expected =
                "-2.0";
            Assert.That(given.repr, Is.EqualTo(expected));

            // Computing determinants for a stack of matrices:

            // >>> a = cp.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
            // >>> a.shape
            // (3, 2, 2)
            // >>> cp.linalg.det(a)
            // array([-2., -3., -8.])
            // 

            a = cp.array(new[,,] { { { 1, 2 }, { 3, 4 } }, { { 1, 2 }, { 2, 1 } }, { { 1, 3 }, { 3, 1 } } });
            var shape = a.shape;
            expected =
                "(3, 2, 2)";
            Assert.That(expected, Is.EqualTo(shape.ToString()));
            given = LA.det(a);
            expected =
                "array([-2., -3., -8.], dtype=float64)";
            Assert.That(given.repr, Is.EqualTo(expected));
        }

#if NOT_IMPLEMENTED
        [Test]
        public void eigTest()
        {
            // (Almost) trivial example with real e-values and e-vectors.

            // >>> w, v = LA.eig(cp.diag((1, 2, 3)))
            // >>> w; v
            // array([ 1.,  2.,  3.])
            // array([[ 1.,  0.,  0.],
            //        [ 0.,  1.,  0.],
            //        [ 0.,  0.,  1.]])
            // 

            var (w, v) = LA.eig(cp.diag(new double[] { 1, 2, 3 }));
            Assert.That("array([1., 2., 3.])", w.repr);
            var expected =
                "array([[1., 0., 0.],\n" +
                "       [0., 1., 0.],\n" +
                "       [0., 0., 1.]])";
            Assert.That(expected, v.repr);
            // Real matrix possessing complex e-values and e-vectors; note that the
            // e-values are complex conjugates of each other.

            // >>> w, v = LA.eig(cp.array([[1, -1], [1, 1]]))
            // >>> w; v
            // array([ 1. + 1.j,  1. - 1.j])
            // array([[ 0.70710678+0.j        ,  0.70710678+0.j        ],
            //        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]])
            // 

#if TODO
             given = w, v = LA.eig(cp.array({{1, -1}, {1, 1}}));
             given = w; v;
             expected =
                "array([ 1. + 1.j,  1. - 1.j])\n" +
                "array([[ 0.70710678+0.j        ,  0.70710678+0.j        ],\n" +
                "       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]])";
            Assert.That(expected, given.repr);
#endif
            // Complex-valued matrix with real e-values (but complex-valued e-vectors);
            // note that a.conj().T = a, i.e., a is Hermitian.

            // >>> a = cp.array([[1, 1j], [-1j, 1]])
            // >>> w, v = LA.eig(a)
            // >>> w; v
            // array([  2.00000000e+00+0.j,   5.98651912e-36+0.j]) # i.e., {2, 0}
            // array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ],
            //        [ 0.70710678+0.j        ,  0.00000000+0.70710678j]])
            // 

#if TODO
             given = a = cp.array({{1, 1j}, {-1j, 1}});
             given = w, v = LA.eig(a);
             given = w; v;
             expected =
                "array([  2.00000000e+00+0.j,   5.98651912e-36+0.j]) # i.e., {2, 0}\n" +
                "array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ],\n" +
                "       [ 0.70710678+0.j        ,  0.00000000+0.70710678j]])";
            Assert.That(expected, given.repr);
#endif
            // Be careful about round-off error!

            // >>> a = cp.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
            // >>> # Theor. e-values are 1 +/- 1e-9
            // >>> w, v = LA.eig(a)
            // >>> w; v
            // array([ 1.,  1.])
            // array([[ 1.,  0.],
            //        [ 0.,  1.]])
            // 

#if TODO
             given = a = cp.array({{1 + 1e-9, 0}, {0, 1 - 1e-9}});
             given = # Theor. e-values are 1 +/- 1e-9;
             given = w, v = LA.eig(a);
             given = w; v;
             expected =
                "array([ 1.,  1.])\n" +
                "array([[ 1.,  0.],\n" +
                "       [ 0.,  1.]])";
            Assert.That(expected, given.repr);
#endif
        }
#endif

        [Test]
        public void eighTest()
        {
            // >>> from Cupy import linalg as LA
            // >>> a = cp.array([[1, -2j], [2j, 5]])
            // >>> a
            // array([[ 1.+0.j,  0.-2.j],
            //        [ 0.+2.j,  5.+0.j]])
            // >>> w, v = LA.eigh(a)
            // >>> w; v
            // array([ 0.17157288,  5.82842712])
            // array([[-0.92387953+0.j        , -0.38268343+0.j        ],
            //        [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])
            // 

#if TODO
            var given = from Cupy import linalg as LA;
             given = a = cp.array({{1, -2j}, {2j, 5}});
             given = a;
            var expected =
                "array([[ 1.+0.j,  0.-2.j],\n" +
                "       [ 0.+2.j,  5.+0.j]])";
            Assert.That(expected, given.repr);
             given = w, v = LA.eigh(a);
             given = w; v;
             expected =
                "array([ 0.17157288,  5.82842712])\n" +
                "array([[-0.92387953+0.j        , -0.38268343+0.j        ],\n" +
                "       [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])";
            Assert.That(expected, given.repr);
#endif
            // >>> cp.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
            // array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j])
            // >>> cp.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
            // array([ 0.+0.j,  0.+0.j])
            // 

#if TODO
             given = cp.dot(a, v{:, 0}) - w{0} * v{:, 0} # verify 1st e-val/vec pair;
             expected =
                "array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j])";
            Assert.That(expected, given.repr);
             given = cp.dot(a, v{:, 1}) - w{1} * v{:, 1} # verify 2nd e-val/vec pair;
             expected =
                "array([ 0.+0.j,  0.+0.j])";
            Assert.That(expected, given.repr);
#endif
            // >>> A = cp.matrix(a) # what happens if input is a matrix object
            // >>> A
            // matrix([[ 1.+0.j,  0.-2.j],
            //         [ 0.+2.j,  5.+0.j]])
            // >>> w, v = LA.eigh(A)
            // >>> w; v
            // array([ 0.17157288,  5.82842712])
            // matrix([[-0.92387953+0.j        , -0.38268343+0.j        ],
            //         [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])
            // 

#if TODO
             given = A = cp.matrix(a) # what happens if input is a matrix object;
             given = A;
             expected =
                "matrix([[ 1.+0.j,  0.-2.j],\n" +
                "        [ 0.+2.j,  5.+0.j]])";
            Assert.That(expected, given.repr);
             given = w, v = LA.eigh(A);
             given = w; v;
             expected =
                "array([ 0.17157288,  5.82842712])\n" +
                "matrix([[-0.92387953+0.j        , -0.38268343+0.j        ],\n" +
                "        [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])";
            Assert.That(expected, given.repr);
#endif
            // >>> # demonstrate the treatment of the imaginary part of the diagonal
            // >>> a = cp.array([[5+2j, 9-2j], [0+2j, 2-1j]])
            // >>> a
            // array([[ 5.+2.j,  9.-2.j],
            //        [ 0.+2.j,  2.-1.j]])
            // >>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
            // >>> b = cp.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
            // >>> b
            // array([[ 5.+0.j,  0.-2.j],
            //        [ 0.+2.j,  2.+0.j]])
            // >>> wa, va = LA.eigh(a)
            // >>> wb, vb = LA.eig(b)
            // >>> wa; wb
            // array([ 1.,  6.])
            // array([ 6.+0.j,  1.+0.j])
            // >>> va; vb
            // array([[-0.44721360-0.j        , -0.89442719+0.j        ],
            //        [ 0.00000000+0.89442719j,  0.00000000-0.4472136j ]])
            // array([[ 0.89442719+0.j       ,  0.00000000-0.4472136j],
            //        [ 0.00000000-0.4472136j,  0.89442719+0.j       ]])
            // 

#if TODO
             given = # demonstrate the treatment of the imaginary part of the diagonal;
             given = a = cp.array({{5+2j, 9-2j}, {0+2j, 2-1j}});
             given = a;
             expected =
                "array([[ 5.+2.j,  9.-2.j],\n" +
                "       [ 0.+2.j,  2.-1.j]])";
            Assert.That(expected, given.repr);
             given = # with UPLO = 'L' this is numerically equivalent to using LA.eig() with:;
             given = b = cp.array({{5.+0.j, 0.-2.j}, {0.+2.j, 2.-0.j}});
             given = b;
             expected =
                "array([[ 5.+0.j,  0.-2.j],\n" +
                "       [ 0.+2.j,  2.+0.j]])";
            Assert.That(expected, given.repr);
             given = wa, va = LA.eigh(a);
             given = wb, vb = LA.eig(b);
             given = wa; wb;
             expected =
                "array([ 1.,  6.])\n" +
                "array([ 6.+0.j,  1.+0.j])";
            Assert.That(expected, given.repr);
             given = va; vb;
             expected =
                "array([[-0.44721360-0.j        , -0.89442719+0.j        ],\n" +
                "       [ 0.00000000+0.89442719j,  0.00000000-0.4472136j ]])\n" +
                "array([[ 0.89442719+0.j       ,  0.00000000-0.4472136j],\n" +
                "       [ 0.00000000-0.4472136j,  0.89442719+0.j       ]])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void eigvalsTest()
        {
            // Illustration, using the fact that the eigenvalues of a diagonal matrix
            // are its diagonal elements, that multiplying a matrix on the left
            // by an orthogonal matrix, Q, and on the right by Q.T (the transpose
            // of Q), preserves the eigenvalues of the “middle” matrix.  In other words,
            // if Q is orthogonal, then Q * A * Q.T has the same eigenvalues as
            // A:

            // >>> from Cupy import linalg as LA
            // >>> x = cp.random.random()
            // >>> Q = cp.array([[cp.cos(x), -cp.sin(x)], [cp.sin(x), cp.cos(x)]])
            // >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), cp.dot(Q[0, :],Q[1, :])
            // (1.0, 1.0, 0.0)
            // 

#if TODO
            var given = from Cupy import linalg as LA;
             given = x = cp.random.random();
             given = Q = cp.array({{cp.cos(x), -cp.sin(x)}, {cp.sin(x), cp.cos(x)}});
             given = LA.norm(Q{0, :}), LA.norm(Q{1, :}), cp.dot(Q{0, :},Q{1, :});
            var expected =
                "(1.0, 1.0, 0.0)";
            Assert.That(expected, given.repr);
#endif
            // Now multiply a diagonal matrix by Q on one side and by Q.T on the other:

            // >>> D = cp.diag((-1,1))
            // >>> LA.eigvals(D)
            // array([-1.,  1.])
            // >>> A = cp.dot(Q, D)
            // >>> A = cp.dot(A, Q.T)
            // >>> LA.eigvals(A)
            // array([ 1., -1.])
            // 

#if TODO
             given = D = cp.diag((-1,1));
             given = LA.eigvals(D);
             expected =
                "array([-1.,  1.])";
            Assert.That(expected, given.repr);
             given = A = cp.dot(Q, D);
             given = A = cp.dot(A, Q.T);
             given = LA.eigvals(A);
             expected =
                "array([ 1., -1.])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void eigvalshTest()
        {
            // >>> from Cupy import linalg as LA
            // >>> a = cp.array([[1, -2j], [2j, 5]])
            // >>> LA.eigvalsh(a)
            // array([ 0.17157288,  5.82842712])
            // 

#if TODO
            var given = from Cupy import linalg as LA;
             given = a = cp.array({{1, -2j}, {2j, 5}});
             given = LA.eigvalsh(a);
            var expected =
                "array([ 0.17157288,  5.82842712])";
            Assert.That(expected, given.repr);
#endif
            // >>> # demonstrate the treatment of the imaginary part of the diagonal
            // >>> a = cp.array([[5+2j, 9-2j], [0+2j, 2-1j]])
            // >>> a
            // array([[ 5.+2.j,  9.-2.j],
            //        [ 0.+2.j,  2.-1.j]])
            // >>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
            // >>> # with:
            // >>> b = cp.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
            // >>> b
            // array([[ 5.+0.j,  0.-2.j],
            //        [ 0.+2.j,  2.+0.j]])
            // >>> wa = LA.eigvalsh(a)
            // >>> wb = LA.eigvals(b)
            // >>> wa; wb
            // array([ 1.,  6.])
            // array([ 6.+0.j,  1.+0.j])
            // 

#if TODO
             given = # demonstrate the treatment of the imaginary part of the diagonal;
             given = a = cp.array({{5+2j, 9-2j}, {0+2j, 2-1j}});
             given = a;
             expected =
                "array([[ 5.+2.j,  9.-2.j],\n" +
                "       [ 0.+2.j,  2.-1.j]])";
            Assert.That(expected, given.repr);
             given = # with UPLO = 'L' this is numerically equivalent to using LA.eigvals();
             given = # with:;
             given = b = cp.array({{5.+0.j, 0.-2.j}, {0.+2.j, 2.-0.j}});
             given = b;
             expected =
                "array([[ 5.+0.j,  0.-2.j],\n" +
                "       [ 0.+2.j,  2.+0.j]])";
            Assert.That(expected, given.repr);
             given = wa = LA.eigvalsh(a);
             given = wb = LA.eigvals(b);
             given = wa; wb;
             expected =
                "array([ 1.,  6.])\n" +
                "array([ 6.+0.j,  1.+0.j])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void invTest()
        {
            // >>> from Cupy.linalg import inv
            // >>> a = cp.array([[1., 2.], [3., 4.]])
            // >>> ainv = inv(a)
            // >>> cp.allclose(cp.dot(a, ainv), cp.eye(2))
            // True
            // >>> cp.allclose(cp.dot(ainv, a), cp.eye(2))
            // True
            // 

#if TODO
            var given = from Cupy.linalg import inv;
             given = a = cp.array({{1., 2.}, {3., 4.}});
             given = ainv = inv(a);
             given = cp.allclose(cp.dot(a, ainv), cp.eye(2));
            var expected =
                "True";
            Assert.That(expected, given.repr);
             given = cp.allclose(cp.dot(ainv, a), cp.eye(2));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
            // If a is a matrix object, then the return value is a matrix as well:

            // >>> ainv = inv(cp.matrix(a))
            // >>> ainv
            // matrix([[-2. ,  1. ],
            //         [ 1.5, -0.5]])
            // 

#if TODO
             given = ainv = inv(cp.matrix(a));
             given = ainv;
             expected =
                "matrix([[-2. ,  1. ],\n" +
                "        [ 1.5, -0.5]])";
            Assert.That(expected, given.repr);
#endif
            // Inverses of several matrices can be computed at once:

            // >>> a = cp.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
            // >>> inv(a)
            // array([[[-2. ,  1. ],
            //         [ 1.5, -0.5]],
            //        [[-5. ,  2. ],
            //         [ 3. , -1. ]]])
            // 

#if TODO
             given = a = cp.array({{{1., 2.}, {3., 4.}}, {{1, 3}, {3, 5}}});
             given = inv(a);
             expected =
                "array([[[-2. ,  1. ],\n" +
                "        [ 1.5, -0.5]],\n" +
                "       [[-5. ,  2. ],\n" +
                "        [ 3. , -1. ]]])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void lstsqTest()
        {
            // Fit a line, y = mx + c, through some noisy data-points:

            // >>> x = cp.array([0, 1, 2, 3])
            // >>> y = cp.array([-1, 0.2, 0.9, 2.1])
            // 

#if TODO
            var given = x = cp.array({0, 1, 2, 3});
             given = y = cp.array({-1, 0.2, 0.9, 2.1});
#endif
            // By examining the coefficients, we see that the line should have a
            // gradient of roughly 1 and cut the y-axis at, more or less, -1.

            // We can rewrite the line equation as y = Ap, where A = [[x 1]]
            // and p = [[m], [c]].  Now use lstsq to solve for p:

            // >>> A = cp.vstack([x, cp.ones(len(x))]).T
            // >>> A
            // array([[ 0.,  1.],
            //        [ 1.,  1.],
            //        [ 2.,  1.],
            //        [ 3.,  1.]])
            // 

#if TODO
             given = A = cp.vstack({x, cp.ones(len(x))}).T;
             given = A;
            var expected =
                "array([[ 0.,  1.],\n" +
                "       [ 1.,  1.],\n" +
                "       [ 2.,  1.],\n" +
                "       [ 3.,  1.]])";
            Assert.That(expected, given.repr);
#endif
            // >>> m, c = cp.linalg.lstsq(A, y, rcond=None)[0]
            // >>> print(m, c)
            // 1.0 -0.95
            // 

#if TODO
             given = m, c = cp.linalg.lstsq(A, y, rcond = None){0};
             given = print(m, c);
             expected =
                "1.0 -0.95";
            Assert.That(expected, given.repr);
#endif
            // Plot the data along with the fitted line:

            // >>> import matplotlib.pyplot as plt
            // >>> plt.plot(x, y, 'o', label='Original data', markersize=10)
            // >>> plt.plot(x, m*x + c, 'r', label='Fitted line')
            // >>> plt.legend()
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = plt.plot(x, y, 'o', label = 'Original data', markersize = 10);
             given = plt.plot(x, m*x + c, 'r', label = 'Fitted line');
             given = plt.legend();
             given = plt.show();
#endif
        }


        [Test]
        public void normTest()
        {
            // >>> from Cupy import linalg as LA
            // >>> a = cp.arange(9) - 4
            // >>> a
            // array([-4, -3, -2, -1,  0,  1,  2,  3,  4])
            // >>> b = a.reshape((3, 3))
            // >>> b
            // array([[-4, -3, -2],
            //        [-1,  0,  1],
            //        [ 2,  3,  4]])
            // 
            var a = cp.arange(9) - 4;
            var given = a;
            var expected =
                "array([-4, -3, -2, -1,  0,  1,  2,  3,  4])";
            Assert.That(given.repr, Is.EqualTo(expected));
            var b = a.reshape(3, 3);
            given = b;
            expected =
                "array([[-4, -3, -2],\n" +
                "       [-1,  0,  1],\n" +
                "       [ 2,  3,  4]])";
            Assert.That(given.repr, Is.EqualTo(expected));

            // >>> LA.norm(a)
            // 7.745966692414834
            // >>> LA.norm(b)
            // 7.745966692414834
            // >>> LA.norm(b, 'fro')
            // 7.745966692414834
            // >>> LA.norm(a, cp.inf)
            // 4.0
            // >>> LA.norm(b, cp.inf)
            // 9.0
            // >>> LA.norm(a, -cp.inf)
            // 0.0
            // >>> LA.norm(b, -cp.inf)
            // 2.0
            // 

            Assert.That((float)LA.norm(a), Is.EqualTo(7.74596669f));
            Assert.That((float)LA.norm(b), Is.EqualTo(7.74596669f));
            Assert.That((float)LA.norm(b, "fro"), Is.EqualTo(7.74596669f));
            Assert.That(LA.norm(a, Constants.inf), Is.EqualTo(4));
            Assert.That(LA.norm(b, Constants.inf), Is.EqualTo(9));
            Assert.That(LA.norm(a, Constants.neg_inf), Is.EqualTo(0));
            Assert.That(LA.norm(b, Constants.neg_inf), Is.EqualTo(2));

            // >>> LA.norm(a, 1)
            // 20.0
            // >>> LA.norm(b, 1)
            // 7.0
            // >>> LA.norm(a, -1)
            // -4.6566128774142013e-010
            // >>> LA.norm(b, -1)
            // 6.0
            // >>> LA.norm(a, 2)
            // 7.745966692414834
            // >>> LA.norm(b, 2)
            // 7.3484692283495345
            // 

            Assert.That((float)LA.norm(a, 1), Is.EqualTo(20f));
            Assert.That((float)LA.norm(b, 1), Is.EqualTo(7f));
            Assert.That((float)LA.norm(a, -1), Is.EqualTo(0f));
            Assert.That((float)LA.norm(b, -1), Is.EqualTo(6));
            Assert.That((float)LA.norm(a, 2), Is.EqualTo(7.74596669f));
            Assert.That((float)LA.norm(b, 2), Is.EqualTo(7.34846922f));

            // >>> LA.norm(a, -2)
            // 0.0
            // >>> LA.norm(b, -2)
            // 1.8570331885190563e-016
            // >>> LA.norm(a, 3)
            // 5.8480354764257312
            // >>> LA.norm(a, -3)
            // 0.0
            // 

            Assert.That((float)LA.norm(a, -2), Is.EqualTo(0f));
            Assert.That((float)LA.norm(b, -2), Is.EqualTo(4.69687703e-17f));
            Assert.That((float)LA.norm(a, 3), Is.EqualTo(5.84803548f));
            Assert.That((float)LA.norm(a, -3), Is.EqualTo(0f));

            // Using the axis argument to compute vector norms:

            // >>> c = cp.array([[ 1, 2, 3],
            // ...               [-1, 1, 4]])
            // >>> LA.norm(c, axis=0)
            // array([ 1.41421356,  2.23606798,  5.        ])
            // >>> LA.norm(c, axis=1)
            // array([ 3.74165739,  4.24264069])
            // >>> LA.norm(c, ord=1, axis=1)
            // array([ 6.,  6.])
            // 
            var c = cp.array(new[,] { { 1, 2, 3 }, { -1, 1, 4 } });
            given = LA.norm(c, axis: 0);
            expected =
                "array([1.41421356, 2.23606798, 5.        ], dtype=float64)";
            Assert.That(given.repr, Is.EqualTo(expected));
            given = LA.norm(c, axis: 1);
            expected =
                "array([3.74165739, 4.24264069], dtype=float64)";
            Assert.That(given.repr, Is.EqualTo(expected));
            given = LA.norm(c, 1, 1);
            expected =
                "array([6., 6.], dtype=float64)";
            Assert.That(given.repr, Is.EqualTo(expected));


            // Using the axis argument to compute matrix norms:

            // >>> m = cp.arange(8).reshape(2,2,2)
            // >>> LA.norm(m, axis=(1,2))
            // array([  3.74165739,  11.22497216])
            // >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
            // (3.7416573867739413, 11.224972160321824)
            // 
            var m = cp.arange(8).reshape(2, 2, 2);
            given = LA.norm(m, new[] { 1, 2 });
            expected =
                "array([ 3.74165739, 11.22497216], dtype=float64)";
            Assert.That(given.repr, Is.EqualTo(expected));
            var given1 = new[] { LA.norm(m["0, :, :"]), LA.norm(m["1, :, :"]) };
            expected =
                "(3.7416573867739413, 11.224972160321824)";
            Assert.That(expected, Is.EqualTo(given1.repr()));
        }

        [Test]
        public void pinvTest()
        {
            // The following example checks that a * a+ * a == a and
            // a+ * a * a+ == a+:

            // >>> a = cp.random.randn(9, 6)
            // >>> B = cp.linalg.pinv(a)
            // >>> cp.allclose(a, cp.dot(a, cp.dot(B, a)))
            // True
            // >>> cp.allclose(B, cp.dot(B, cp.dot(a, B)))
            // True
            // 

#if TODO
            var given = a = cp.random.randn(9, 6);
             given = B = cp.linalg.pinv(a);
             given = cp.allclose(a, cp.dot(a, cp.dot(B, a)));
            var expected =
                "True";
            Assert.That(expected, given.repr);
             given = cp.allclose(B, cp.dot(B, cp.dot(a, B)));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void solveTest()
        {
            // Solve the system of equations 3 * x0 + x1 = 9 and x0 + 2 * x1 = 8:

            // >>> a = cp.array([[3,1], [1,2]])
            // >>> b = cp.array([9,8])
            // >>> x = cp.linalg.solve(a, b)
            // >>> x
            // array([ 2.,  3.])
            // 

#if TODO
            var given = a = cp.array({{3,1}, {1,2}});
             given = b = cp.array({9,8});
             given = x = cp.linalg.solve(a, b);
             given = x;
            var expected =
                "array([ 2.,  3.])";
            Assert.That(expected, given.repr);
#endif
            // Check that the solution is correct:

            // >>> cp.allclose(cp.dot(a, x), b)
            // True
            // 

#if TODO
             given = cp.allclose(cp.dot(a, x), b);
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void svdTest()
        {
            // >>> a = cp.random.randn(9, 6) + 1j*cp.random.randn(9, 6)
            // >>> b = cp.random.randn(2, 7, 8, 3) + 1j*cp.random.randn(2, 7, 8, 3)
            // 

#if TODO
            var given = a = cp.random.randn(9, 6) + 1j*cp.random.randn(9, 6);
             given = b = cp.random.randn(2, 7, 8, 3) + 1j*cp.random.randn(2, 7, 8, 3);
#endif
            // Reconstruction based on full SVD, 2D case:

            // >>> u, s, vh = cp.linalg.svd(a, full_matrices=True)
            // >>> u.shape, s.shape, vh.shape
            // ((9, 9), (6,), (6, 6))
            // >>> cp.allclose(a, cp.dot(u[:, :6] * s, vh))
            // True
            // >>> smat = cp.zeros((9, 6), dtype=complex)
            // >>> smat[:6, :6] = cp.diag(s)
            // >>> cp.allclose(a, cp.dot(u, cp.dot(smat, vh)))
            // True
            // 

#if TODO
             given = u, s, vh = cp.linalg.svd(a, full_matrices = True);
             given = u.shape, s.shape, vh.shape;
            var expected =
                "((9, 9), (6,), (6, 6))";
            Assert.That(expected, given.repr);
             given = cp.allclose(a, cp.dot(u{:, :6} * s, vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
             given = smat = cp.zeros((9, 6), dtype = complex);
             given = smat{:6, :6} = cp.diag(s);
             given = cp.allclose(a, cp.dot(u, cp.dot(smat, vh)));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
            // Reconstruction based on reduced SVD, 2D case:

            // >>> u, s, vh = cp.linalg.svd(a, full_matrices=False)
            // >>> u.shape, s.shape, vh.shape
            // ((9, 6), (6,), (6, 6))
            // >>> cp.allclose(a, cp.dot(u * s, vh))
            // True
            // >>> smat = cp.diag(s)
            // >>> cp.allclose(a, cp.dot(u, cp.dot(smat, vh)))
            // True
            // 

#if TODO
             given = u, s, vh = cp.linalg.svd(a, full_matrices = False);
             given = u.shape, s.shape, vh.shape;
             expected =
                "((9, 6), (6,), (6, 6))";
            Assert.That(expected, given.repr);
             given = cp.allclose(a, cp.dot(u * s, vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
             given = smat = cp.diag(s);
             given = cp.allclose(a, cp.dot(u, cp.dot(smat, vh)));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
            // Reconstruction based on full SVD, 4D case:

            // >>> u, s, vh = cp.linalg.svd(b, full_matrices=True)
            // >>> u.shape, s.shape, vh.shape
            // ((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
            // >>> cp.allclose(b, cp.matmul(u[..., :3] * s[..., None, :], vh))
            // True
            // >>> cp.allclose(b, cp.matmul(u[..., :3], s[..., None] * vh))
            // True
            // 

#if TODO
             given = u, s, vh = cp.linalg.svd(b, full_matrices = True);
             given = u.shape, s.shape, vh.shape;
             expected =
                "((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))";
            Assert.That(expected, given.repr);
             given = cp.allclose(b, cp.matmul(u{..., :3} * s{..., None, :}, vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
             given = cp.allclose(b, cp.matmul(u{..., :3}, s{..., None} * vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
            // Reconstruction based on reduced SVD, 4D case:

            // >>> u, s, vh = cp.linalg.svd(b, full_matrices=False)
            // >>> u.shape, s.shape, vh.shape
            // ((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
            // >>> cp.allclose(b, cp.matmul(u * s[..., None, :], vh))
            // True
            // >>> cp.allclose(b, cp.matmul(u, s[..., None] * vh))
            // True
            // 

#if TODO
             given = u, s, vh = cp.linalg.svd(b, full_matrices = False);
             given = u.shape, s.shape, vh.shape;
             expected =
                "((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))";
            Assert.That(expected, given.repr);
             given = cp.allclose(b, cp.matmul(u * s{..., None, :}, vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
             given = cp.allclose(b, cp.matmul(u, s{..., None} * vh));
             expected =
                "True";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void fftTest()
        {
            // >>> cp.fft.fft(cp.exp(2j * cp.pi * cp.arange(8) / 8))
            // array([ -3.44505240e-16 +1.14383329e-17j,
            //          8.00000000e+00 -5.71092652e-15j,
            //          2.33482938e-16 +1.22460635e-16j,
            //          1.64863782e-15 +1.77635684e-15j,
            //          9.95839695e-17 +2.33482938e-16j,
            //          0.00000000e+00 +1.66837030e-15j,
            //          1.14383329e-17 +1.22460635e-16j,
            //          -1.64863782e-15 +1.77635684e-15j])
            // 

#if TODO
            var given = cp.fft.fft(cp.exp(2j * cp.pi * cp.arange(8) / 8));
            var expected =
                "array([ -3.44505240e-16 +1.14383329e-17j,\n" +
                "         8.00000000e+00 -5.71092652e-15j,\n" +
                "         2.33482938e-16 +1.22460635e-16j,\n" +
                "         1.64863782e-15 +1.77635684e-15j,\n" +
                "         9.95839695e-17 +2.33482938e-16j,\n" +
                "         0.00000000e+00 +1.66837030e-15j,\n" +
                "         1.14383329e-17 +1.22460635e-16j,\n" +
                "         -1.64863782e-15 +1.77635684e-15j])";
            Assert.That(expected, given.repr);
#endif
            // In this example, real input has an FFT which is Hermitian, i.e., symmetric
            // in the real part and anti-symmetric in the imaginary part, as described in
            // the Cupy.fft documentation:

            // >>> import matplotlib.pyplot as plt
            // >>> t = cp.arange(256)
            // >>> sp = cp.fft.fft(cp.sin(t))
            // >>> freq = cp.fft.fftfreq(t.shape[-1])
            // >>> plt.plot(freq, sp.real, freq, sp.imag)
            // [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = t = cp.arange(256);
             given = sp = cp.fft.fft(cp.sin(t));
             given = freq = cp.fft.fftfreq(t.shape{-1});
             given = plt.plot(freq, sp.real, freq, sp.imag);
             expected =
                "[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]";
            Assert.That(expected, given.repr);
             given = plt.show();
#endif
        }


        [Test]
        public void fft2Test()
        {
            // >>> a = cp.mgrid[:5, :5][0]
            // >>> cp.fft.fft2(a)
            // array([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,
            //           0.0 +0.j        ,   0.0 +0.j        ],
            //        [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
            //           0.0 +0.j        ,   0.0 +0.j        ],
            //        [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
            //           0.0 +0.j        ,   0.0 +0.j        ],
            //        [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
            //             0.0 +0.j        ,   0.0 +0.j        ],
            //        [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
            //           0.0 +0.j        ,   0.0 +0.j        ]])
            // 

#if TODO
            var given = a = cp.mgrid{:5, :5}{0};
             given = cp.fft.fft2(a);
            var expected =
                "array([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,\n" +
                "          0.0 +0.j        ,   0.0 +0.j        ],\n" +
                "       [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n" +
                "          0.0 +0.j        ,   0.0 +0.j        ],\n" +
                "       [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n" +
                "          0.0 +0.j        ,   0.0 +0.j        ],\n" +
                "       [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n" +
                "            0.0 +0.j        ,   0.0 +0.j        ],\n" +
                "       [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n" +
                "          0.0 +0.j        ,   0.0 +0.j        ]])";
            Assert.That(expected, given.repr);
#endif
        }


        [Test]
        public void fftnTest()
        {
            // >>> a = cp.mgrid[:3, :3, :3][0]
            // >>> cp.fft.fftn(a, axes=(1, 2))
            // array([[[  0.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j]],
            //        [[  9.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j]],
            //        [[ 18.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j],
            //         [  0.+0.j,   0.+0.j,   0.+0.j]]])
            // >>> cp.fft.fftn(a, (2, 2), axes=(0, 1))
            // array([[[ 2.+0.j,  2.+0.j,  2.+0.j],
            //         [ 0.+0.j,  0.+0.j,  0.+0.j]],
            //        [[-2.+0.j, -2.+0.j, -2.+0.j],
            //         [ 0.+0.j,  0.+0.j,  0.+0.j]]])
            // 

#if TODO
            var given = a = cp.mgrid{:3, :3, :3}{0};
             given = cp.fft.fftn(a, axes = (1, 2));
            var expected =
                "array([[[  0.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j]],\n" +
                "       [[  9.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j]],\n" +
                "       [[ 18.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j],\n" +
                "        [  0.+0.j,   0.+0.j,   0.+0.j]]])";
            Assert.That(expected, given.repr);
             given = cp.fft.fftn(a, (2, 2), axes = (0, 1));
             expected =
                "array([[[ 2.+0.j,  2.+0.j,  2.+0.j],\n" +
                "        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n" +
                "       [[-2.+0.j, -2.+0.j, -2.+0.j],\n" +
                "        [ 0.+0.j,  0.+0.j,  0.+0.j]]])";
            Assert.That(expected, given.repr);
#endif
            // >>> import matplotlib.pyplot as plt
            // >>> [X, Y] = cp.meshgrid(2 * cp.pi * cp.arange(200) / 12,
            // ...                      2 * cp.pi * cp.arange(200) / 34)
            // >>> S = cp.sin(X) + cp.cos(Y) + cp.random.uniform(0, 1, X.shape)
            // >>> FS = cp.fft.fftn(S)
            // >>> plt.imshow(cp.log(cp.abs(cp.fft.fftshift(FS))**2))
            // <matplotlib.image.AxesImage object at 0x...>
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = {X, Y} = cp.meshgrid(2 * cp.pi * cp.arange(200) / 12,;
             expected =
                "...                      2 * cp.pi * cp.arange(200) / 34)";
            Assert.That(expected, given.repr);
             given = S = cp.sin(X) + cp.cos(Y) + cp.random.uniform(0, 1, X.shape);
             given = FS = cp.fft.fftn(S);
             given = plt.imshow(cp.log(cp.abs(cp.fft.fftshift(FS))**2));
             expected =
                "<matplotlib.image.AxesImage object at 0x...>";
            Assert.That(expected, given.repr);
             given = plt.show();
#endif
        }


        [Test]
        public void ifftTest()
        {
            // >>> cp.fft.ifft([0, 4, 0, 0])
            // array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])
            // 

#if TODO
            var given = cp.fft.ifft({0, 4, 0, 0});
            var expected =
                "array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])";
            Assert.That(expected, given.repr);
#endif
            // Create and plot a band-limited signal with random phases:

            // >>> import matplotlib.pyplot as plt
            // >>> t = cp.arange(400)
            // >>> n = cp.zeros((400,), dtype=complex)
            // >>> n[40:60] = cp.exp(1j*cp.random.uniform(0, 2*cp.pi, (20,)))
            // >>> s = cp.fft.ifft(n)
            // >>> plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
            // ...
            // >>> plt.legend(('real', 'imaginary'))
            // ...
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = t = cp.arange(400);
             given = n = cp.zeros((400,), dtype = complex);
             given = n{40:60} = cp.exp(1j*cp.random.uniform(0, 2*cp.pi, (20,)));
             given = s = cp.fft.ifft(n);
             given = plt.plot(t, s.real, 'b-', t, s.imag, 'r--');
             expected =
                "...";
            Assert.That(expected, given.repr);
             given = plt.legend(('real', 'imaginary'));
             expected =
                "...";
            Assert.That(expected, given.repr);
             given = plt.show();
#endif
        }


        [Test]
        public void ifft2Test()
        {
            // >>> a = 4 * cp.eye(4)
            // >>> cp.fft.ifft2(a)
            // array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
            //        [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
            //        [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
            //        [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
            //   

            var a = cp.eye(4) * 4;
            var given = cp.fft.ifft2(a);
            var expected =
                "array([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n" +
                "       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n" +
                "       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n" +
                "       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]], dtype=complex128)";
            Assert.That(given.repr, Is.EqualTo(expected));
        }


        [Test]
        public void ifftnTest()
        {
            // >>> a = cp.eye(4)
            // >>> cp.fft.ifftn(cp.fft.fftn(a, axes=(0,)), axes=(1,))
            // array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
            //        [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
            //        [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
            //        [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])
            // 

#if TODO
            var given = a = cp.eye(4);
             given = cp.fft.ifftn(cp.fft.fftn(a, axes = (0,)), axes = (1,));
            var expected =
                "array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n" +
                "       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n" +
                "       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n" +
                "       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])";
            Assert.That(expected, given.repr);
#endif
            // Create and plot an image with band-limited frequency content:

            // >>> import matplotlib.pyplot as plt
            // >>> n = cp.zeros((200,200), dtype=complex)
            // >>> n[60:80, 20:40] = cp.exp(1j*cp.random.uniform(0, 2*cp.pi, (20, 20)))
            // >>> im = cp.fft.ifftn(n).real
            // >>> plt.imshow(im)
            // <matplotlib.image.AxesImage object at 0x...>
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = n = cp.zeros((200,200), dtype = complex);
             given = n{60:80, 20:40} = cp.exp(1j*cp.random.uniform(0, 2*cp.pi, (20, 20)));
             given = im = cp.fft.ifftn(n).real;
             given = plt.imshow(im);
             expected =
                "<matplotlib.image.AxesImage object at 0x...>";
            Assert.That(expected, given.repr);
             given = plt.show();
#endif
        }


        [Test]
        public void i0Test()
        {
            // >>> cp.i0([0.])
            // array(1.0)
            // >>> cp.i0([0., 1. + 2j])
            // array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])
            // 

#if TODO
            var given = cp.i0({0.});
            var expected =
                "array(1.0)";
            Assert.That(expected, given.repr);
             given = cp.i0({0., 1. + 2j});
             expected =
                "array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])";
            Assert.That(expected, given.repr);
#endif
        }
    }
}