// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using NUnit.Framework;

namespace Cupy.UnitTest
{
    [TestFixture]
    public class Cupy_staticsticsTest : BaseTestCase
    {
        [Test]
        public void aminTest()
        {
            // >>> a = cp.arange(4).reshape((2,2))
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> cp.amin(a)           # Minimum of the flattened array
            // 0
            // >>> cp.amin(a, axis=0)   # Minima along the first axis
            // array([0, 1])
            // >>> cp.amin(a, axis=1)   # Minima along the second axis
            // array([0, 2])
            // 

            var a = cp.arange(4).reshape(2, 2);
            var given = a;
            var expected =
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
            given = a.amin(); // Minimum of the flattened array;
            expected =
                "0";
            Assert.AreEqual(expected, given.repr);
            given = a.amin(new[] { 0 }); // Minima along the first axis;
            expected =
                "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
            given = a.amin(new[] { 1 }); // Minima along the second axis;
            expected =
                "array([0, 2])";
            Assert.AreEqual(expected, given.repr);

            // >>> b = cp.arange(5, dtype=float)
            // >>> b[2] = cp.NaN
            // >>> cp.amin(b)
            // nan
            // >>> cp.nanmin(b)
            // 0.0
            // 

#if TODO
             given = b = cp.arange(5, dtype = float);
             given = b{2} = cp.NaN;
             given = cp.amin(b);
             expected =
                "nan";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmin(b);
             expected =
                "0.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.min([[-50], [10]], axis=-1, initial=0)
            // array([-50,   0])
            // 

#if TODO
             given = cp.min({{-50}, {10}}, axis = -1, initial = 0);
             expected =
                "array([-50,   0])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Notice that the initial value is used as one of the elements for which the
            // minimum is determined, unlike for the default argument Python’s max
            // function, which is only used for empty iterables.

            // Notice that this isn’t the same as Python’s default argument.

            // >>> cp.min([6], initial=5)
            // 5
            // >>> min([6], default=5)
            // 6
            // 

#if TODO
             given = cp.min({6}, initial = 5);
             expected =
                "5";
            Assert.AreEqual(expected, given.repr);
             given = min([6], default = 5);
             expected =
                "6";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void amaxTest()
        {
            // >>> a = cp.arange(4).reshape((2,2))
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> cp.amax(a)           # Maximum of the flattened array
            // 3
            // >>> cp.amax(a, axis=0)   # Maxima along the first axis
            // array([2, 3])
            // >>> cp.amax(a, axis=1)   # Maxima along the second axis
            // array([1, 3])
            // 

#if TODO
            var given = a = cp.arange(4).reshape((2,2));
             given = a;
            var expected =
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.amax(a)           # Maximum of the flattened array;
             expected =
                "3";
            Assert.AreEqual(expected, given.repr);
             given = cp.amax(a, axis = 0)   # Maxima along the first axis;
             expected =
                "array([2, 3])";
            Assert.AreEqual(expected, given.repr);
             given = cp.amax(a, axis = 1)   # Maxima along the second axis;
             expected =
                "array([1, 3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> b = cp.arange(5, dtype=float)
            // >>> b[2] = cp.NaN
            // >>> cp.amax(b)
            // nan
            // >>> cp.nanmax(b)
            // 4.0
            // 

#if TODO
             given = b = cp.arange(5, dtype = float);
             given = b{2} = cp.NaN;
             given = cp.amax(b);
             expected =
                "nan";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmax(b);
             expected =
                "4.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // You can use an initial value to compute the maximum of an empty slice, or
            // to initialize it to a different value:

            // >>> cp.max([[-50], [10]], axis=-1, initial=0)
            // array([ 0, 10])
            // 

#if TODO
             given = cp.max({{-50}, {10}}, axis = -1, initial = 0);
             expected =
                "array([ 0, 10])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Notice that the initial value is used as one of the elements for which the
            // maximum is determined, unlike for the default argument Python’s max
            // function, which is only used for empty iterables.

            // >>> cp.max([5], initial=6)
            // 6
            // >>> max([5], default=6)
            // 5
            // 

#if TODO
             given = cp.max({5}, initial = 6);
             expected =
                "6";
            Assert.AreEqual(expected, given.repr);
             given = max([5], default = 6);
             expected =
                "5";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanminTest()
        {
            // >>> a = cp.array([[1, 2], [3, cp.nan]])
            // >>> cp.nanmin(a)
            // 1.0
            // >>> cp.nanmin(a, axis=0)
            // array([ 1.,  2.])
            // >>> cp.nanmin(a, axis=1)
            // array([ 1.,  3.])
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, cp.nan}});
             given = cp.nanmin(a);
            var expected =
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmin(a, axis = 0);
             expected =
                "array([ 1.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmin(a, axis = 1);
             expected =
                "array([ 1.,  3.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // When positive infinity and negative infinity are present:

            // >>> cp.nanmin([1, 2, cp.nan, cp.inf])
            // 1.0
            // >>> cp.nanmin([1, 2, cp.nan, cp.NINF])
            // -inf
            // 

#if TODO
             given = cp.nanmin({1, 2, cp.nan, cp.inf});
             expected =
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmin({1, 2, cp.nan, cp.NINF});
             expected =
                "-inf";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanmaxTest()
        {
            // >>> a = cp.array([[1, 2], [3, cp.nan]])
            // >>> cp.nanmax(a)
            // 3.0
            // >>> cp.nanmax(a, axis=0)
            // array([ 3.,  2.])
            // >>> cp.nanmax(a, axis=1)
            // array([ 2.,  3.])
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, cp.nan}});
             given = cp.nanmax(a);
            var expected =
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmax(a, axis = 0);
             expected =
                "array([ 3.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmax(a, axis = 1);
             expected =
                "array([ 2.,  3.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // When positive infinity and negative infinity are present:

            // >>> cp.nanmax([1, 2, cp.nan, cp.NINF])
            // 2.0
            // >>> cp.nanmax([1, 2, cp.nan, cp.inf])
            // inf
            // 

#if TODO
             given = cp.nanmax({1, 2, cp.nan, cp.NINF});
             expected =
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmax({1, 2, cp.nan, cp.inf});
             expected =
                "inf";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void ptpTest()
        {
            // >>> x = cp.arange(4).reshape((2,2))
            // >>> x
            // array([[0, 1],
            //        [2, 3]])
            // 

#if TODO
            var given = x = cp.arange(4).reshape((2,2));
             given = x;
            var expected =
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.ptp(x, axis=0)
            // array([2, 2])
            // 

#if TODO
             given = cp.ptp(x, axis = 0);
             expected =
                "array([2, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> cp.ptp(x, axis=1)
            // array([1, 1])
            // 

#if TODO
             given = cp.ptp(x, axis = 1);
             expected =
                "array([1, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void percentileTest()
        {
            // >>> a = cp.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> cp.percentile(a, 50)
            // 3.5
            // >>> cp.percentile(a, 50, axis=0)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> cp.percentile(a, 50, axis=1)
            // array([ 7.,  2.])
            // >>> cp.percentile(a, 50, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // 

#if TODO
            var given = a = cp.array({{10, 7, 4}, {3, 2, 1}});
             given = a;
            var expected =
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.percentile(a, 50);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.percentile(a, 50, axis = 0);
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.percentile(a, 50, axis = 1);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.percentile(a, 50, axis = 1, keepdims = True);
             expected =
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> m = cp.percentile(a, 50, axis=0)
            // >>> out = cp.zeros_like(m)
            // >>> cp.percentile(a, 50, axis=0, out=out)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> m
            // array([[ 6.5,  4.5,  2.5]])
            // 

#if TODO
             given = m = cp.percentile(a, 50, axis = 0);
             given = out = cp.zeros_like(m);
             given = cp.percentile(a, 50, axis = 0, out = out);
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given = m;
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> b = a.copy()
            // >>> cp.percentile(b, 50, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not cp.all(a == b)
            // 

#if TODO
             given = b = a.copy();
             given = cp.percentile(b, 50, axis = 1, overwrite_input = True);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a == b);
#endif
            // The different types of interpolation can be visualized graphically:

            // import matplotlib.pyplot as plt
            // 
            // a = cp.arange(4)
            // p = cp.linspace(0, 100, 6001)
            // ax = plt.gca()
            // lines = [
            //     ('linear', None),
            //     ('higher', '--'),
            //     ('lower', '--'),
            //     ('nearest', '-.'),
            //     ('midpoint', '-.'),
            // ]
            // for interpolation, style in lines:
            //     ax.plot(
            //         p, cp.percentile(a, p, interpolation=interpolation),
            //         label=interpolation, linestyle=style)
            // ax.set(
            //     title='Interpolation methods for list: ' + str(a),
            //     xlabel='Percentile',
            //     ylabel='List item returned',
            //     yticks=a)
            // ax.legend()
            // plt.show()
            // 

#if TODO
             expected =
                "import matplotlib.pyplot as plt\n" +
                "\n" +
                "a = cp.arange(4)\n" +
                "p = cp.linspace(0, 100, 6001)\n" +
                "ax = plt.gca()\n" +
                "lines = [\n" +
                "    ('linear', None),\n" +
                "    ('higher', '--'),\n" +
                "    ('lower', '--'),\n" +
                "    ('nearest', '-.'),\n" +
                "    ('midpoint', '-.'),\n" +
                "]\n" +
                "for interpolation, style in lines:\n" +
                "    ax.plot(\n" +
                "        p, cp.percentile(a, p, interpolation=interpolation),\n" +
                "        label=interpolation, linestyle=style)\n" +
                "ax.set(\n" +
                "    title='Interpolation methods for list: ' + str(a),\n" +
                "    xlabel='Percentile',\n" +
                "    ylabel='List item returned',\n" +
                "    yticks=a)\n" +
                "ax.legend()\n" +
                "plt.show()";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanpercentileTest()
        {
            // >>> a = cp.array([[10., 7., 4.], [3., 2., 1.]])
            // >>> a[0][1] = cp.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //       [  3.,   2.,   1.]])
            // >>> cp.percentile(a, 50)
            // nan
            // >>> cp.nanpercentile(a, 50)
            // 3.5
            // >>> cp.nanpercentile(a, 50, axis=0)
            // array([ 6.5,  2.,   2.5])
            // >>> cp.nanpercentile(a, 50, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = cp.nanpercentile(a, 50, axis=0)
            // >>> out = cp.zeros_like(m)
            // >>> cp.nanpercentile(a, 50, axis=0, out=out)
            // array([ 6.5,  2.,   2.5])
            // >>> m
            // array([ 6.5,  2. ,  2.5])
            // 

#if TODO
            var given = a = cp.array({{10., 7., 4.}, {3., 2., 1.}});
             given = a{0}{1} = cp.nan;
             given = a;
            var expected =
                "array([[ 10.,  nan,   4.],\n" +
                "      [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.percentile(a, 50);
             expected =
                "nan";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanpercentile(a, 50);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanpercentile(a, 50, axis = 0);
             expected =
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanpercentile(a, 50, axis = 1, keepdims = True);
             expected =
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given = m = cp.nanpercentile(a, 50, axis = 0);
             given = out = cp.zeros_like(m);
             given = cp.nanpercentile(a, 50, axis = 0, out = out);
             expected =
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given = m;
             expected =
                "array([ 6.5,  2. ,  2.5])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> b = a.copy()
            // >>> cp.nanpercentile(b, 50, axis=1, overwrite_input=True)
            // array([  7.,  2.])
            // >>> assert not cp.all(a==b)
            // 

#if TODO
             given = b = a.copy();
             given = cp.nanpercentile(b, 50, axis = 1, overwrite_input = True);
             expected =
                "array([  7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
#endif
        }


        [Test]
        public void quantileTest()
        {
            // >>> a = cp.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> cp.quantile(a, 0.5)
            // 3.5
            // >>> cp.quantile(a, 0.5, axis=0)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> cp.quantile(a, 0.5, axis=1)
            // array([ 7.,  2.])
            // >>> cp.quantile(a, 0.5, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = cp.quantile(a, 0.5, axis=0)
            // >>> out = cp.zeros_like(m)
            // >>> cp.quantile(a, 0.5, axis=0, out=out)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> m
            // array([[ 6.5,  4.5,  2.5]])
            // >>> b = a.copy()
            // >>> cp.quantile(b, 0.5, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not cp.all(a == b)
            // 

#if TODO
            var given = a = cp.array({{10, 7, 4}, {3, 2, 1}});
             given = a;
            var expected =
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.quantile(a, 0.5);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.quantile(a, 0.5, axis = 0);
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.quantile(a, 0.5, axis = 1);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.quantile(a, 0.5, axis = 1, keepdims = True);
             expected =
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given = m = cp.quantile(a, 0.5, axis = 0);
             given = out = cp.zeros_like(m);
             given = cp.quantile(a, 0.5, axis = 0, out = out);
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given = m;
             expected =
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given = b = a.copy();
             given = cp.quantile(b, 0.5, axis = 1, overwrite_input = True);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a == b);
#endif
        }


        [Test]
        public void nanquantileTest()
        {
            // >>> a = cp.array([[10., 7., 4.], [3., 2., 1.]])
            // >>> a[0][1] = cp.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //       [  3.,   2.,   1.]])
            // >>> cp.quantile(a, 0.5)
            // nan
            // >>> cp.nanquantile(a, 0.5)
            // 3.5
            // >>> cp.nanquantile(a, 0.5, axis=0)
            // array([ 6.5,  2.,   2.5])
            // >>> cp.nanquantile(a, 0.5, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = cp.nanquantile(a, 0.5, axis=0)
            // >>> out = cp.zeros_like(m)
            // >>> cp.nanquantile(a, 0.5, axis=0, out=out)
            // array([ 6.5,  2.,   2.5])
            // >>> m
            // array([ 6.5,  2. ,  2.5])
            // >>> b = a.copy()
            // >>> cp.nanquantile(b, 0.5, axis=1, overwrite_input=True)
            // array([  7.,  2.])
            // >>> assert not cp.all(a==b)
            // 

#if TODO
            var given = a = cp.array({{10., 7., 4.}, {3., 2., 1.}});
             given = a{0}{1} = cp.nan;
             given = a;
            var expected =
                "array([[ 10.,  nan,   4.],\n" +
                "      [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.quantile(a, 0.5);
             expected =
                "nan";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanquantile(a, 0.5);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanquantile(a, 0.5, axis = 0);
             expected =
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanquantile(a, 0.5, axis = 1, keepdims = True);
             expected =
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given = m = cp.nanquantile(a, 0.5, axis = 0);
             given = out = cp.zeros_like(m);
             given = cp.nanquantile(a, 0.5, axis = 0, out = out);
             expected =
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given = m;
             expected =
                "array([ 6.5,  2. ,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given = b = a.copy();
             given = cp.nanquantile(b, 0.5, axis = 1, overwrite_input = True);
             expected =
                "array([  7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
#endif
        }


        [Test]
        public void medianTest()
        {
            // >>> a = cp.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> cp.median(a)
            // 3.5
            // >>> cp.median(a, axis=0)
            // array([ 6.5,  4.5,  2.5])
            // >>> cp.median(a, axis=1)
            // array([ 7.,  2.])
            // >>> m = cp.median(a, axis=0)
            // >>> out = cp.zeros_like(m)
            // >>> cp.median(a, axis=0, out=m)
            // array([ 6.5,  4.5,  2.5])
            // >>> m
            // array([ 6.5,  4.5,  2.5])
            // >>> b = a.copy()
            // >>> cp.median(b, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not cp.all(a==b)
            // >>> b = a.copy()
            // >>> cp.median(b, axis=None, overwrite_input=True)
            // 3.5
            // >>> assert not cp.all(a==b)
            // 

#if TODO
            var given = a = cp.array({{10, 7, 4}, {3, 2, 1}});
             given = a;
            var expected =
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.median(a);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.median(a, axis = 0);
             expected =
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.median(a, axis = 1);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = m = cp.median(a, axis = 0);
             given = out = cp.zeros_like(m);
             given = cp.median(a, axis = 0, out = m);
             expected =
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given = m;
             expected =
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given = b = a.copy();
             given = cp.median(b, axis = 1, overwrite_input = True);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
             given = b = a.copy();
             given = cp.median(b, axis = None, overwrite_input = True);
             expected =
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
#endif
        }


        [Test]
        public void averageTest()
        {
            // >>> data = range(1,5)
            // >>> data
            // [1, 2, 3, 4]
            // >>> cp.average(data)
            // 2.5
            // >>> cp.average(range(1,11), weights=range(10,0,-1))
            // 4.0
            // 

#if TODO
            var given = data = range(1,5);
             given = data;
            var expected =
                "[1, 2, 3, 4]";
            Assert.AreEqual(expected, given.repr);
             given = cp.average(data);
             expected =
                "2.5";
            Assert.AreEqual(expected, given.repr);
             given = cp.average(range(1,11), weights = range(10,0,-1));
             expected =
                "4.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> data = cp.arange(6).reshape((3,2))
            // >>> data
            // array([[0, 1],
            //        [2, 3],
            //        [4, 5]])
            // >>> cp.average(data, axis=1, weights=[1./4, 3./4])
            // array([ 0.75,  2.75,  4.75])
            // >>> cp.average(data, weights=[1./4, 3./4])
            // 

#if TODO
             given = data = cp.arange(6).reshape((3,2));
             given = data;
             expected =
                "array([[0, 1],\n" +
                "       [2, 3],\n" +
                "       [4, 5]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.average(data, axis = 1, weights = {1./4, 3./4});
             expected =
                "array([ 0.75,  2.75,  4.75])";
            Assert.AreEqual(expected, given.repr);
             given = cp.average(data, weights = {1./4, 3./4});
#endif
            // Traceback (most recent call last):
            // …
            // TypeError: Axis must be specified when shapes of a and weights differ.

            // >>> a = cp.ones(5, dtype=cp.float128)
            // >>> w = cp.ones(5, dtype=cp.complex64)
            // >>> avg = cp.average(a, weights=w)
            // >>> print(avg.dtype)
            // complex256
            // 

#if TODO
             given = a = cp.ones(5, dtype = cp.float128);
             given = w = cp.ones(5, dtype = cp.complex64);
             given = avg = cp.average(a, weights = w);
             given = print(avg.dtype);
             expected =
                "complex256";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void meanTest()
        {
            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> cp.mean(a)
            // 2.5
            // >>> cp.mean(a, axis=0)
            // array([ 2.,  3.])
            // >>> cp.mean(a, axis=1)
            // array([ 1.5,  3.5])
            // 

            NDarray a = cp.array(new[,] { { 1, 2 }, { 3, 4 } });
            var given_scalar = a.mean();
            Assert.AreEqual(2.5, given_scalar);
            var given = a.mean(0);
            var expected =
                "array([2., 3.], dtype=float64)";
            Assert.AreEqual(expected, given.repr);
            given = a.mean(1);
            expected =
                "array([1.5, 3.5], dtype=float64)";
            Assert.AreEqual(expected, given.repr);

            // In single precision, mean can be inaccurate:

            // >>> a = cp.zeros((2, 512*512), dtype=cp.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> cp.mean(a)
            // 0.54999924
            // 

            a = cp.zeros((2, 512 * 512), cp.float32);
            a["0, :"] = (NDarray)1.0;
            a["1, :"] = (NDarray)0.1;
            given_scalar = Math.Round(a.mean(), 8);
            var expected_scalar =
                0.54999995000000002d;
            Assert.AreEqual(expected_scalar, given_scalar);

            // Computing the mean in float64 is more accurate:

            // >>> cp.mean(a, dtype=cp.float64)
            // 0.55000000074505806
            // 

            given_scalar = a.mean(cp.float64);
            expected_scalar =
                0.55000000074505806;
            Assert.AreEqual(expected_scalar, given_scalar);
        }


        [Test]
        public void stdTest()
        {
            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> cp.std(a)
            // 1.1180339887498949
            // >>> cp.std(a, axis=0)
            // array([ 1.,  1.])
            // >>> cp.std(a, axis=1)
            // array([ 0.5,  0.5])
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, 4}});
             given = cp.std(a);
            var expected =
                "1.1180339887498949";
            Assert.AreEqual(expected, given.repr);
             given = cp.std(a, axis = 0);
             expected =
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.std(a, axis = 1);
             expected =
                "array([ 0.5,  0.5])";
            Assert.AreEqual(expected, given.repr);
#endif
            // In single precision, std() can be inaccurate:

            // >>> a = cp.zeros((2, 512*512), dtype=cp.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> cp.std(a)
            // 0.45000005
            // 

#if TODO
             given = a = cp.zeros((2, 512*512), dtype = cp.float32);
             given = a[0, :] = 1.0;
             given = a[1, :] = 0.1;
             given = cp.std(a);
             expected =
                "0.45000005";
            Assert.AreEqual(expected, given.repr);
#endif
            // Computing the standard deviation in float64 is more accurate:

            // >>> cp.std(a, dtype=cp.float64)
            // 0.44999999925494177
            // 

#if TODO
             given = cp.std(a, dtype = cp.float64);
             expected =
                "0.44999999925494177";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void varTest()
        {
            // >>> a = cp.array([[1, 2], [3, 4]])
            // >>> cp.var(a)
            // 1.25
            // >>> cp.var(a, axis=0)
            // array([ 1.,  1.])
            // >>> cp.var(a, axis=1)
            // array([ 0.25,  0.25])
            // 

#if TODO
            var given = a = cp.array({{1, 2}, {3, 4}});
             given = cp.var(a);
            var expected =
                "1.25";
            Assert.AreEqual(expected, given.repr);
             given = cp.var(a, axis = 0);
             expected =
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.var(a, axis = 1);
             expected =
                "array([ 0.25,  0.25])";
            Assert.AreEqual(expected, given.repr);
#endif
            // In single precision, var() can be inaccurate:

            // >>> a = cp.zeros((2, 512*512), dtype=cp.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> cp.var(a)
            // 0.20250003
            // 

#if TODO
             given = a = cp.zeros((2, 512*512), dtype = cp.float32);
             given = a[0, :] = 1.0;
             given = a[1, :] = 0.1;
             given = cp.var(a);
             expected =
                "0.20250003";
            Assert.AreEqual(expected, given.repr);
#endif
            // Computing the variance in float64 is more accurate:

            // >>> cp.var(a, dtype=cp.float64)
            // 0.20249999932944759
            // >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
            // 0.2025
            // 

#if TODO
             given = cp.var(a, dtype = cp.float64);
             expected =
                "0.20249999932944759";
            Assert.AreEqual(expected, given.repr);
             given = ((1-0.55)**2 + (0.1-0.55)**2)/2;
             expected =
                "0.2025";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanmedianTest()
        {
            // >>> a = cp.array([[10.0, 7, 4], [3, 2, 1]])
            // >>> a[0, 1] = cp.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //    [  3.,   2.,   1.]])
            // >>> cp.median(a)
            // nan
            // >>> cp.nanmedian(a)
            // 3.0
            // >>> cp.nanmedian(a, axis=0)
            // array([ 6.5,  2.,  2.5])
            // >>> cp.median(a, axis=1)
            // array([ 7.,  2.])
            // >>> b = a.copy()
            // >>> cp.nanmedian(b, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not cp.all(a==b)
            // >>> b = a.copy()
            // >>> cp.nanmedian(b, axis=None, overwrite_input=True)
            // 3.0
            // >>> assert not cp.all(a==b)
            // 

#if TODO
            var given = a = cp.array({{10.0, 7, 4}, {3, 2, 1}});
             given = a{0, 1} = cp.nan;
             given = a;
            var expected =
                "array([[ 10.,  nan,   4.],\n" +
                "   [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given = cp.median(a);
             expected =
                "nan";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmedian(a);
             expected =
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmedian(a, axis = 0);
             expected =
                "array([ 6.5,  2.,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.median(a, axis = 1);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = b = a.copy();
             given = cp.nanmedian(b, axis = 1, overwrite_input = True);
             expected =
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
             given = b = a.copy();
             given = cp.nanmedian(b, axis = None, overwrite_input = True);
             expected =
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given = assert not cp.all(a==b);
#endif
        }


        [Test]
        public void nanmeanTest()
        {
            // >>> a = cp.array([[1, cp.nan], [3, 4]])
            // >>> cp.nanmean(a)
            // 2.6666666666666665
            // >>> cp.nanmean(a, axis=0)
            // array([ 2.,  4.])
            // >>> cp.nanmean(a, axis=1)
            // array([ 1.,  3.5])
            // 

#if TODO
            var given = a = cp.array({{1, cp.nan}, {3, 4}});
             given = cp.nanmean(a);
            var expected =
                "2.6666666666666665";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmean(a, axis = 0);
             expected =
                "array([ 2.,  4.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanmean(a, axis = 1);
             expected =
                "array([ 1.,  3.5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanstdTest()
        {
            // >>> a = cp.array([[1, cp.nan], [3, 4]])
            // >>> cp.nanstd(a)
            // 1.247219128924647
            // >>> cp.nanstd(a, axis=0)
            // array([ 1.,  0.])
            // >>> cp.nanstd(a, axis=1)
            // array([ 0.,  0.5])
            // 

#if TODO
            var given = a = cp.array({{1, cp.nan}, {3, 4}});
             given = cp.nanstd(a);
            var expected =
                "1.247219128924647";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanstd(a, axis = 0);
             expected =
                "array([ 1.,  0.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanstd(a, axis = 1);
             expected =
                "array([ 0.,  0.5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void nanvarTest()
        {
            // >>> a = cp.array([[1, cp.nan], [3, 4]])
            // >>> cp.var(a)
            // 1.5555555555555554
            // >>> cp.nanvar(a, axis=0)
            // array([ 1.,  0.])
            // >>> cp.nanvar(a, axis=1)
            // array([ 0.,  0.25])
            // 

#if TODO
            var given = a = cp.array({{1, cp.nan}, {3, 4}});
             given = cp.var(a);
            var expected =
                "1.5555555555555554";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanvar(a, axis = 0);
             expected =
                "array([ 1.,  0.])";
            Assert.AreEqual(expected, given.repr);
             given = cp.nanvar(a, axis = 1);
             expected =
                "array([ 0.,  0.25])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void correlateTest()
        {
            // >>> cp.correlate([1, 2, 3], [0, 1, 0.5])
            // array([ 3.5])
            // >>> cp.correlate([1, 2, 3], [0, 1, 0.5], "same")
            // array([ 2. ,  3.5,  3. ])
            // >>> cp.correlate([1, 2, 3], [0, 1, 0.5], "full")
            // array([ 0.5,  2. ,  3.5,  3. ,  0. ])
            // 

#if TODO
            var given = cp.correlate({1, 2, 3}, {0, 1, 0.5});
            var expected =
                "array([ 3.5])";
            Assert.AreEqual(expected, given.repr);
             given = cp.correlate({1, 2, 3}, {0, 1, 0.5}, "same");
             expected =
                "array([ 2. ,  3.5,  3. ])";
            Assert.AreEqual(expected, given.repr);
             given = cp.correlate({1, 2, 3}, {0, 1, 0.5}, "full");
             expected =
                "array([ 0.5,  2. ,  3.5,  3. ,  0. ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Using complex sequences:

            // >>> cp.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
            // array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
            // 

#if TODO
             given = cp.correlate({1+1j, 2, 3-1j}, {0, 1, 0.5j}, 'full');
             expected =
                "array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note that you get the time reversed, complex conjugated result
            // when the two input sequences change places, i.e.,
            // c_{va}[k] = c^{*}_{av}[-k]:

            // >>> cp.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
            // array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
            // 

#if TODO
             given = cp.correlate({0, 1, 0.5j}, {1+1j, 2, 3-1j}, 'full');
             expected =
                "array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void covTest()
        {
            // Consider two variables,  and , which
            // correlate perfectly, but in opposite directions:

            // >>> x = cp.array([[0, 2], [1, 1], [2, 0]]).T
            // >>> x
            // array([[0, 1, 2],
            //        [2, 1, 0]])
            // 

#if TODO
            var given = x = cp.array({{0, 2}, {1, 1}, {2, 0}}).T;
             given = x;
            var expected =
                "array([[0, 1, 2],\n" +
                "       [2, 1, 0]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note how  increases while  decreases. The covariance
            // matrix shows this clearly:

            // >>> cp.cov(x)
            // array([[ 1., -1.],
            //        [-1.,  1.]])
            // 

#if TODO
             given = cp.cov(x);
             expected =
                "array([[ 1., -1.],\n" +
                "       [-1.,  1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note that element , which shows the correlation between
            //  and , is negative.

            // Further, note how x and y are combined:

            // >>> x = [-2.1, -1,  4.3]
            // >>> y = [3,  1.1,  0.12]
            // >>> X = cp.stack((x, y), axis=0)
            // >>> print(cp.cov(X))
            // [[ 11.71        -4.286     ]
            //  [ -4.286        2.14413333]]
            // >>> print(cp.cov(x, y))
            // [[ 11.71        -4.286     ]
            //  [ -4.286        2.14413333]]
            // >>> print(cp.cov(x))
            // 11.71
            // 

#if TODO
             given = x = [-2.1, -1,  4.3];
             given = y = [3,  1.1,  0.12];
             given = X = cp.stack((x, y), axis = 0);
             given = print(cp.cov(X));
             expected =
                "[[ 11.71        -4.286     ]\n" +
                " [ -4.286        2.14413333]]";
            Assert.AreEqual(expected, given.repr);
             given = print(cp.cov(x, y));
             expected =
                "[[ 11.71        -4.286     ]\n" +
                " [ -4.286        2.14413333]]";
            Assert.AreEqual(expected, given.repr);
             given = print(cp.cov(x));
             expected =
                "11.71";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void histogramTest()
        {
            // >>> cp.histogram([1, 2, 1], bins=[0, 1, 2, 3])
            // (array([0, 2, 1]), array([0, 1, 2, 3]))
            // >>> cp.histogram(cp.arange(4), bins=cp.arange(5), density=True)
            // (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))
            // >>> cp.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
            // (array([1, 4, 1]), array([0, 1, 2, 3]))
            // 

#if TODO
            var given = cp.histogram({1, 2, 1}, bins = {0, 1, 2, 3});
            var expected =
                "(array([0, 2, 1]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
             given = cp.histogram(cp.arange(4), bins = cp.arange(5), density = True);
             expected =
                "(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))";
            Assert.AreEqual(expected, given.repr);
             given = cp.histogram({{1, 2, 1}, {1, 0, 1}}, bins = {0,1,2,3});
             expected =
                "(array([1, 4, 1]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> a = cp.arange(5)
            // >>> hist, bin_edges = cp.histogram(a, density=True)
            // >>> hist
            // array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])
            // >>> hist.sum()
            // 2.4999999999999996
            // >>> cp.sum(hist * cp.diff(bin_edges))
            // 1.0
            // 

#if TODO
             given = a = cp.arange(5);
             given = hist, bin_edges = cp.histogram(a, density = True);
             given = hist;
             expected =
                "array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])";
            Assert.AreEqual(expected, given.repr);
             given = hist.sum();
             expected =
                "2.4999999999999996";
            Assert.AreEqual(expected, given.repr);
             given = cp.sum(hist * cp.diff(bin_edges));
             expected =
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // Automated Bin Selection Methods example, using 2 peak random data
            // with 2000 points:

            // >>> import matplotlib.pyplot as plt
            // >>> rng = cp.random.RandomState(10)  # deterministic random data
            // >>> a = cp.hstack((rng.normal(size=1000),
            // ...                rng.normal(loc=5, scale=2, size=1000)))
            // >>> plt.hist(a, bins='auto')  # arguments are passed to cp.histogram
            // >>> plt.title("Histogram with 'auto' bins")
            // >>> plt.show()
            // 

#if TODO
             given = import matplotlib.pyplot as plt;
             given = rng = cp.random.RandomState(10)  # deterministic random data;
             given = a = cp.hstack((rng.normal(size = 1000),;
             expected =
                "...                rng.normal(loc=5, scale=2, size=1000)))";
            Assert.AreEqual(expected, given.repr);
             given = plt.hist(a, bins = 'auto')  # arguments are passed to cp.histogram;
             given = plt.title("Histogram with 'auto' bins");
             given = plt.show();
#endif
        }


        [Test]
        public void histogram2dTest()
        {
            // >>> from matplotlib.image import NonUniformImage
            // >>> import matplotlib.pyplot as plt
            // 

#if TODO
            var given = from matplotlib.image import NonUniformImage;
             given = import matplotlib.pyplot as plt;
#endif
            // Construct a 2-D histogram with variable bin width. First define the bin
            // edges:

            // >>> xedges = [0, 1, 3, 5]
            // >>> yedges = [0, 2, 3, 4, 6]
            // 

#if TODO
             given = xedges = [0, 1, 3, 5];
             given = yedges = [0, 2, 3, 4, 6];
#endif
            // Next we create a histogram H with random bin content:

            // >>> x = cp.random.normal(2, 1, 100)
            // >>> y = cp.random.normal(1, 1, 100)
            // >>> H, xedges, yedges = cp.histogram2d(x, y, bins=(xedges, yedges))
            // >>> H = H.T  # Let each row list bins with common y range.
            // 

#if TODO
             given = x = cp.random.normal(2, 1, 100);
             given = y = cp.random.normal(1, 1, 100);
             given = H, xedges, yedges = cp.histogram2d(x, y, bins = (xedges, yedges));
             given = H = H.T  # Let each row list bins with common y range.;
#endif
            // imshow can only display square bins:

            // >>> fig = plt.figure(figsize=(7, 3))
            // >>> ax = fig.add_subplot(131, title='imshow: square bins')
            // >>> plt.imshow(H, interpolation='nearest', origin='low',
            // ...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
            // 

#if TODO
             given = fig = plt.figure(figsize = (7, 3));
             given = ax = fig.add_subplot(131, title = 'imshow: square bins');
             given = plt.imshow(H, interpolation = 'nearest', origin = 'low',;
            var expected =
                "...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // pcolormesh can display actual edges:

            // >>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
            // ...         aspect='equal')
            // >>> X, Y = cp.meshgrid(xedges, yedges)
            // >>> ax.pcolormesh(X, Y, H)
            // 

#if TODO
             given = ax = fig.add_subplot(132, title = 'pcolormesh: actual edges',;
             expected =
                "...         aspect='equal')";
            Assert.AreEqual(expected, given.repr);
             given = X, Y = cp.meshgrid(xedges, yedges);
             given = ax.pcolormesh(X, Y, H);
#endif
            // NonUniformImage can be used to
            // display actual bin edges with interpolation:

            // >>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
            // ...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
            // >>> im = NonUniformImage(ax, interpolation='bilinear')
            // >>> xcenters = (xedges[:-1] + xedges[1:]) / 2
            // >>> ycenters = (yedges[:-1] + yedges[1:]) / 2
            // >>> im.set_data(xcenters, ycenters, H)
            // >>> ax.images.append(im)
            // >>> plt.show()
            // 

#if TODO
             given = ax = fig.add_subplot(133, title = 'NonUniformImage: interpolated',;
             expected =
                "...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])";
            Assert.AreEqual(expected, given.repr);
             given = im = NonUniformImage(ax, interpolation = 'bilinear');
             given = xcenters = (xedges[:-1] + xedges[1:]) / 2;
             given = ycenters = (yedges[:-1] + yedges[1:]) / 2;
             given = im.set_data(xcenters, ycenters, H);
             given = ax.images.append(im);
             given = plt.show();
#endif
        }


        [Test]
        public void histogramddTest()
        {
            // >>> r = cp.random.randn(100,3)
            // >>> H, edges = cp.histogramdd(r, bins = (5, 8, 4))
            // >>> H.shape, edges[0].size, edges[1].size, edges[2].size
            // ((5, 8, 4), 6, 9, 5)
            // 

#if TODO
            var given = r = cp.random.randn(100,3);
             given = H, edges = cp.histogramdd(r, bins = (5, 8, 4));
             given = H.shape, edges[0].size, edges[1].size, edges[2].size;
            var expected =
                "((5, 8, 4), 6, 9, 5)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void bincountTest()
        {
            // >>> cp.bincount(cp.arange(5))
            // array([1, 1, 1, 1, 1])
            // >>> cp.bincount(cp.array([0, 1, 1, 3, 2, 1, 7]))
            // array([1, 3, 1, 1, 0, 0, 0, 1])
            // 

#if TODO
            var given = cp.bincount(cp.arange(5));
            var expected =
                "array([1, 1, 1, 1, 1])";
            Assert.AreEqual(expected, given.repr);
             given = cp.bincount(cp.array({0, 1, 1, 3, 2, 1, 7}));
             expected =
                "array([1, 3, 1, 1, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = cp.array([0, 1, 1, 3, 2, 1, 7, 23])
            // >>> cp.bincount(x).size == cp.amax(x)+1
            // True
            // 

#if TODO
             given = x = cp.array({0, 1, 1, 3, 2, 1, 7, 23});
             given = cp.bincount(x).size == cp.amax(x)+1;
             expected =
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // The input array needs to be of integer dtype, otherwise a
            // TypeError is raised:

            // >>> cp.bincount(cp.arange(5, dtype=float))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // TypeError: array cannot be safely cast to required type
            // 

#if TODO
             given = cp.bincount(cp.arange(5, dtype = float));
             expected =
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "TypeError: array cannot be safely cast to required type";
            Assert.AreEqual(expected, given.repr);
#endif
            // A possible use of bincount is to perform sums over
            // variable-size chunks of an array, using the weights keyword.

            // >>> w = cp.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
            // >>> x = cp.array([0, 1, 1, 2, 2, 2])
            // >>> cp.bincount(x,  weights=w)
            // array([ 0.3,  0.7,  1.1])
            // 

#if TODO
             given = w = cp.array({0.3, 0.5, 0.2, 0.7, 1., -0.6}) # weights;
             given = x = cp.array({0, 1, 1, 2, 2, 2});
             given = cp.bincount(x,  weights = w);
             expected =
                "array([ 0.3,  0.7,  1.1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void histogram_bin_edgesTest()
        {
            // >>> arr = cp.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
            // >>> cp.histogram_bin_edges(arr, bins='auto', range=(0, 1))
            // array([0.  , 0.25, 0.5 , 0.75, 1.  ])
            // >>> cp.histogram_bin_edges(arr, bins=2)
            // array([0. , 2.5, 5. ])
            // 

#if TODO
            var given = arr = cp.array({0, 0, 0, 1, 2, 3, 3, 4, 5});
             given = cp.histogram_bin_edges(arr, bins = 'auto', range = (0, 1));
            var expected =
                "array([0.  , 0.25, 0.5 , 0.75, 1.  ])";
            Assert.AreEqual(expected, given.repr);
             given = cp.histogram_bin_edges(arr, bins = 2);
             expected =
                "array([0. , 2.5, 5. ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // For consistency with histogram, an array of pre-computed bins is
            // passed through unmodified:

            // >>> cp.histogram_bin_edges(arr, [1, 2])
            // array([1, 2])
            // 

#if TODO
             given = cp.histogram_bin_edges(arr, {1, 2});
             expected =
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // This function allows one set of bins to be computed, and reused across
            // multiple histograms:

            // >>> shared_bins = cp.histogram_bin_edges(arr, bins='auto')
            // >>> shared_bins
            // array([0., 1., 2., 3., 4., 5.])
            // 

#if TODO
             given = shared_bins = cp.histogram_bin_edges(arr, bins = 'auto');
             given = shared_bins;
             expected =
                "array([0., 1., 2., 3., 4., 5.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> group_id = cp.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
            // >>> hist_0, _ = cp.histogram(arr[group_id == 0], bins=shared_bins)
            // >>> hist_1, _ = cp.histogram(arr[group_id == 1], bins=shared_bins)
            // 

#if TODO
             given = group_id = cp.array({0, 1, 1, 0, 1, 1, 0, 1, 1});
             given = hist_0, _ = cp.histogram(arr{group_id == 0}, bins = shared_bins);
             given = hist_1, _ = cp.histogram(arr{group_id == 1}, bins = shared_bins);
#endif
            // >>> hist_0; hist_1
            // array([1, 1, 0, 1, 0])
            // array([2, 0, 1, 1, 2])
            // 

#if TODO
             given = hist_0; hist_1;
             expected =
                "array([1, 1, 0, 1, 0])\n" +
                "array([2, 0, 1, 1, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Which gives more easily comparable results than using separate bins for
            // each histogram:

            // >>> hist_0, bins_0 = cp.histogram(arr[group_id == 0], bins='auto')
            // >>> hist_1, bins_1 = cp.histogram(arr[group_id == 1], bins='auto')
            // >>> hist_0; hist1
            // array([1, 1, 1])
            // array([2, 1, 1, 2])
            // >>> bins_0; bins_1
            // array([0., 1., 2., 3.])
            // array([0.  , 1.25, 2.5 , 3.75, 5.  ])
            // 

#if TODO
             given = hist_0, bins_0 = cp.histogram(arr{group_id == 0}, bins = 'auto');
             given = hist_1, bins_1 = cp.histogram(arr{group_id == 1}, bins = 'auto');
             given = hist_0; hist1;
             expected =
                "array([1, 1, 1])\n" +
                "array([2, 1, 1, 2])";
            Assert.AreEqual(expected, given.repr);
             given = bins_0; bins_1;
             expected =
                "array([0., 1., 2., 3.])\n" +
                "array([0.  , 1.25, 2.5 , 3.75, 5.  ])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [Test]
        public void digitizeTest()
        {
            // >>> x = cp.array([0.2, 6.4, 3.0, 1.6])
            // >>> bins = cp.array([0.0, 1.0, 2.5, 4.0, 10.0])
            // >>> inds = cp.digitize(x, bins)
            // >>> inds
            // array([1, 4, 3, 2])
            // >>> for n in range(x.size):
            // ...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
            // ...
            // 0.0 <= 0.2 < 1.0
            // 4.0 <= 6.4 < 10.0
            // 2.5 <= 3.0 < 4.0
            // 1.0 <= 1.6 < 2.5
            // 

#if TODO
            var given = x = cp.array({0.2, 6.4, 3.0, 1.6});
             given = bins = cp.array({0.0, 1.0, 2.5, 4.0, 10.0});
             given = inds = cp.digitize(x, bins);
             given = inds;
            var expected =
                "array([1, 4, 3, 2])";
            Assert.AreEqual(expected, given.repr);
             given = for n in range(x.size):;
             expected =
                "...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])\n" +
                "...\n" +
                "0.0 <= 0.2 < 1.0\n" +
                "4.0 <= 6.4 < 10.0\n" +
                "2.5 <= 3.0 < 4.0\n" +
                "1.0 <= 1.6 < 2.5";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = cp.array([1.2, 10.0, 12.4, 15.5, 20.])
            // >>> bins = cp.array([0, 5, 10, 15, 20])
            // >>> cp.digitize(x,bins,right=True)
            // array([1, 2, 3, 4, 4])
            // >>> cp.digitize(x,bins,right=False)
            // array([1, 3, 3, 4, 5])
            // 

#if TODO
             given = x = cp.array({1.2, 10.0, 12.4, 15.5, 20.});
             given = bins = cp.array({0, 5, 10, 15, 20});
             given = cp.digitize(x,bins,right = True);
             expected =
                "array([1, 2, 3, 4, 4])";
            Assert.AreEqual(expected, given.repr);
             given = cp.digitize(x,bins,right = False);
             expected =
                "array([1, 3, 3, 4, 5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }
    }
}